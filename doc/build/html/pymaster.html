<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Python API documentation &mdash; pymaster 1.0.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Example 1: simple pseudo-Cl computation" href="sample_simple.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pymaster
          </a>
              <div class="version">
                1.0.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Python API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="sample_simple.html">Example 1: simple pseudo-Cl computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="sample_bins.html">Example 2: Bandpowers</a></li>
<li class="toctree-l1"><a class="reference internal" href="sample_fields.html">Example 3: Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="sample_masks.html">Example 4: Masks</a></li>
<li class="toctree-l1"><a class="reference internal" href="sample_workspaces.html">Example 5: Using workspaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="sample_pureb.html">Example 6: Pure E and B</a></li>
<li class="toctree-l1"><a class="reference internal" href="sample_flat.html">Example 7: Flat-sky fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="sample_covariance.html">Example 8: Computing covariance matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="sample_rectpix.html">Example 9: Rectangular pixels</a></li>
<li class="toctree-l1"><a class="reference internal" href="sample_toeplitz.html">Example 10: The Toeplitz approximation</a></li>
<li class="toctree-l1"><a class="reference external" href="index_doxy.html#http://">C API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pymaster</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Python API documentation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/pymaster.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pymaster">
<span id="python-api-documentation"></span><h1>Python API documentation<a class="headerlink" href="#module-pymaster" title="Permalink to this headline">Â¶</a></h1>
<p><a class="reference internal" href="#module-pymaster" title="pymaster"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymaster</span></code></a> contains three basic classes:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#pymaster.field.NmtField" title="pymaster.field.NmtField"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymaster.field.NmtField</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.bins.NmtBin" title="pymaster.bins.NmtBin"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymaster.bins.NmtBin</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.workspaces.NmtWorkspace" title="pymaster.workspaces.NmtWorkspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymaster.workspaces.NmtWorkspace</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.covariance.NmtCovarianceWorkspace" title="pymaster.covariance.NmtCovarianceWorkspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymaster.covariance.NmtCovarianceWorkspace</span></code></a></p></li>
</ul>
<p>and a number of functions</p>
<ul class="simple">
<li><p><a class="reference internal" href="#pymaster.workspaces.deprojection_bias" title="pymaster.workspaces.deprojection_bias"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.workspaces.deprojection_bias()</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.workspaces.compute_coupled_cell" title="pymaster.workspaces.compute_coupled_cell"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.workspaces.compute_coupled_cell()</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.workspaces.compute_full_master" title="pymaster.workspaces.compute_full_master"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.workspaces.compute_full_master()</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.covariance.gaussian_covariance" title="pymaster.covariance.gaussian_covariance"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.covariance.gaussian_covariance()</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.utils.mask_apodization" title="pymaster.utils.mask_apodization"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.utils.mask_apodization()</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.utils.synfast_spherical" title="pymaster.utils.synfast_spherical"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.utils.synfast_spherical()</span></code></a></p></li>
</ul>
<p><a class="reference internal" href="#module-pymaster" title="pymaster"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymaster</span></code></a> also comes with a flat-sky version with     most of the same functionality:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#pymaster.field.NmtFieldFlat" title="pymaster.field.NmtFieldFlat"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymaster.field.NmtFieldFlat</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.bins.NmtBinFlat" title="pymaster.bins.NmtBinFlat"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymaster.bins.NmtBinFlat</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.workspaces.NmtWorkspaceFlat" title="pymaster.workspaces.NmtWorkspaceFlat"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymaster.workspaces.NmtWorkspaceFlat</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.covariance.NmtCovarianceWorkspaceFlat" title="pymaster.covariance.NmtCovarianceWorkspaceFlat"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymaster.covariance.NmtCovarianceWorkspaceFlat</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.workspaces.deprojection_bias_flat" title="pymaster.workspaces.deprojection_bias_flat"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.workspaces.deprojection_bias_flat()</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.workspaces.compute_coupled_cell_flat" title="pymaster.workspaces.compute_coupled_cell_flat"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.workspaces.compute_coupled_cell_flat()</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.workspaces.compute_full_master_flat" title="pymaster.workspaces.compute_full_master_flat"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.workspaces.compute_full_master_flat()</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.covariance.gaussian_covariance_flat" title="pymaster.covariance.gaussian_covariance_flat"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.covariance.gaussian_covariance_flat()</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.utils.mask_apodization_flat" title="pymaster.utils.mask_apodization_flat"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.utils.mask_apodization_flat()</span></code></a></p></li>
<li><p><a class="reference internal" href="#pymaster.utils.synfast_flat" title="pymaster.utils.synfast_flat"><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.utils.synfast_flat()</span></code></a></p></li>
</ul>
<p>Many of these function accept or return sets of power spectra (arrays with one element per angular multipole) or bandpowers (binned versions of power spectra). In all cases, these are returned and provided as 2D arrays with shape [n_cls][nl], where n_cls is the number of power spectra and nl is either the number of multipoles or bandpowers. In all cases, n_cls should correspond with the spins of the two fields being correlated, and the ordering is as follows:</p>
<ul class="simple">
<li><p>Two spin-0 fields: n_cls=1, [C_T1T2]</p></li>
<li><p>One spin-0 field and one spin&gt;0 field: n_cls=2, [C_TE,C_TB]</p></li>
<li><p>Two spin&gt;0 fields: n_cls=4, [C_E1E2,C_E1B2,C_E2B1,C_B1B2]</p></li>
</ul>
<p>All sky maps accepted and returned by these functions are in the form of HEALPix maps exclusively with RING ordering.</p>
<span class="target" id="module-pymaster.field"></span><dl class="py class">
<dt class="sig sig-object py" id="pymaster.field.NmtField">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymaster.field.</span></span><span class="sig-name descname"><span class="pre">NmtField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">templates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">purify_e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">purify_b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter_mask_purify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_pinv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wcs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lmax_sht</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masked_on_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.field.NmtField" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An NmtField object contains all the information describing the fields to
correlate, including their observed maps, masks and contaminant templates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> â array containing a map corresponding to the fieldâs mask.         Should be 1-dimensional for a HEALPix map or 2-dimensional for a map         with rectangular pixelization.</p></li>
<li><p><strong>maps</strong> â array containing the observed maps for this field. Should be         at least 2-dimensional. The first dimension corresponds to the number         of maps, which should be 1 for a spin-0 field and 2 otherwise.         The other dimensions should be [npix] for HEALPix maps or         [ny,nx] for maps with rectangular pixels. For a spin&gt;0 field, the two         maps to pass should be the usual Q/U Stokes parameters for         polarization, or e1/e2 (gamma1/gamma2 etc.) in the case of cosmic         shear. It is important to note that NaMaster uses the same         polarization convention as HEALPix (i.e. with the x-coordinate         growing with increasing colatitude theta). It is however more common         for galaxy ellipticities to be provided using the IAU convention         (i.e. x grows with declination). In this case, the sign of the         e2/gamma2 map should be swapped before using it to create an         NmtField. See more         <a class="reference external" href="https://healpix.jpl.nasa.gov/html/intronode12.htm">here</a> .         If <cite>None</cite>, this field will only contain a mask but no maps. The field         can then be used to compute a mode-coupling matrix, for instance,         but not actual power spectra.</p></li>
<li><p><strong>spin</strong> â fieldâs spin. If <cite>None</cite> it will be set to 0 if there is
a single map on input, and will default to 2 if there are 2 maps.</p></li>
<li><p><strong>templates</strong> â array containing a set of contaminant templates for         this field. This array should have shape [ntemp][nmap]â¦, where         ntemp is the number of templates, nmap should be 1 for spin-0 fields         and 2 otherwise. The other dimensions should be [npix] for         HEALPix maps or [ny,nx] for maps with rectangular pixels. The         best-fit contribution from each contaminant is automatically removed         from the maps unless templates=None.</p></li>
<li><p><strong>beam</strong> â spherical harmonic transform of the instrumental beam         (assumed to be rotationally symmetric - i.e. no m dependence). If         None, no beam will be corrected for. Otherwise, this array should         have at least as many elements as the maximum multipole sampled by         the maps + 1 (e.g. if a HEALPix map, it should contain 3*nside         elements, corresponding to multipoles from 0 to 3*nside-1).</p></li>
<li><p><strong>purify_e</strong> â use pure E-modes?</p></li>
<li><p><strong>purify_b</strong> â use pure B-modes?</p></li>
<li><p><strong>n_iter_mask_purify</strong> â number of iterations used to compute an         accurate SHT of the mask when using E/B purification.</p></li>
<li><p><strong>tol_pinv</strong> â when computing the pseudo-inverse of the contaminant         covariance matrix, all eigenvalues below tol_pinv * max_eval will be         treated as singular values, where max_eval is the largest eigenvalue.         Only relevant if passing contaminant templates that are likely to be         highly correlated.</p></li>
<li><p><strong>wcs</strong> â a WCS object if using rectangular pixels (see         <a class="reference external" href="http://docs.astropy.org/en/stable/wcs/index.html">http://docs.astropy.org/en/stable/wcs/index.html</a>).</p></li>
<li><p><strong>n_iter</strong> â number of iterations when computing a_lms.</p></li>
<li><p><strong>lmax_sht</strong> â maximum multipole up to which map power spectra will be         computed. If negative or zero, the maximum multipole given the map         resolution will be used (e.g. 3 * nside - 1 for HEALPix maps).</p></li>
<li><p><strong>masked_on_input</strong> â set to <cite>True</cite> if input maps and templates are         already multiplied by the masks. Note that this is not advisable         if youâre using purification.</p></li>
<li><p><strong>lite</strong> â set to <cite>True</cite> if you want to only store the bare minimum         necessary to run a standard pseudo-Cl with deprojection and         purification, but you donât care about deprojection bias. This         will reduce the memory taken up by the resulting object.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pymaster.field.NmtField.get_alms">
<span class="sig-name descname"><span class="pre">get_alms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.field.NmtField.get_alms" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns a 2D array ([nmap][nlm]) corresponding to the observed         harmonic coefficients of this field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>2D array of alms</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.field.NmtField.get_maps">
<span class="sig-name descname"><span class="pre">get_maps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.field.NmtField.get_maps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns a 2D array ([nmap][npix]) corresponding to the observed maps         for this field. If the field was initialized with contaminant         templates, the maps returned by this function have their best-fit         contribution from these contaminants removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>2D array of maps</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.field.NmtField.get_mask">
<span class="sig-name descname"><span class="pre">get_mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.field.NmtField.get_mask" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns this fieldâs mask as a 1D array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>mask</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.field.NmtField.get_templates">
<span class="sig-name descname"><span class="pre">get_templates</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.field.NmtField.get_templates" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns a 3D array ([ntemp][nmap][npix]) corresponding to the         contaminant templates passed when initializing this field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>3D array of maps</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymaster.field.NmtFieldFlat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymaster.field.</span></span><span class="sig-name descname"><span class="pre">NmtFieldFlat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">templates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">purify_e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">purify_b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_pinv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masked_on_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.field.NmtFieldFlat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An NmtFieldFlat object contains all the information describing the     flat-sky fields to correlate, including their observed maps, masks     and contaminant templates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lx</strong><strong>,</strong><strong>ly</strong> (<em>float</em>) â size of the patch in the x and y directions (in         radians)</p></li>
<li><p><strong>mask</strong> â 2D array (nx,ny) containing a HEALPix map corresponding         to the fieldâs mask.</p></li>
<li><p><strong>maps</strong> â 2 2D arrays (nmaps,nx,ny) containing the observed maps         for this field. The first dimension corresponds to the number of         maps, which should be 1 for a spin-0 field and 2 otherwise.         If <cite>None</cite>, this field will only contain a mask but no maps. The field         can then be used to compute a mode-coupling matrix, for instance,         but not actual power spectra.</p></li>
<li><p><strong>spin</strong> â fieldâs spin. If <cite>None</cite> it will be set to 0 if there is
a single map on input, and will default to 2 if there are 2 maps.</p></li>
<li><p><strong>templates</strong> â array of maps (ntemp,nmaps,nx,ny) containing a set         of contaminant templates for this field. This array should have         shape [ntemp][nmap][nx][ny], where ntemp is the number of         templates, nmap should be 1 for spin-0 fields and 2 for spin-2         fields, and nx,ny define the patch. The best-fit contribution         from each contaminant is automatically removed from the maps         unless templates=None</p></li>
<li><p><strong>beam</strong> â 2D array (2,nl) defining the FT of the instrumental beam         (assumed to be rotationally symmetric). beam[0] should contain         the values of l for which de beam is defined, with beam[1]         containing the beam values. If None, no beam will be corrected         for.</p></li>
<li><p><strong>purify_e</strong> â use pure E-modes?</p></li>
<li><p><strong>purify_b</strong> â use pure B-modes?</p></li>
<li><p><strong>tol_pinv</strong> â when computing the pseudo-inverse of the contaminant         covariance matrix, all eigenvalues below tol_pinv * max_eval will         be treated as singular values, where max_eval is the largest         eigenvalue. Only relevant if passing contaminant templates that         are likely to be highly correlated.</p></li>
<li><p><strong>masked_on_input</strong> â set to <cite>True</cite> if input maps and templates are
already multiplied by the masks. Note that this is not advisable
if youâre using purification.</p></li>
<li><p><strong>lite</strong> â set to <cite>True</cite> if you want to only store the bare minimum         necessary to run a standard pseudo-Cl with deprojection and         purification, but you donât care about deprojection bias. This         will reduce the memory taken up by the resulting object.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pymaster.field.NmtFieldFlat.get_maps">
<span class="sig-name descname"><span class="pre">get_maps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.field.NmtFieldFlat.get_maps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns a 3D array ([nmap][ny][nx]) corresponding to the observed         maps for this field. If the field was initialized with contaminant         templates, the maps returned by this function have their best-fit         contribution from these contaminants removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>3D array of flat-sky maps</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.field.NmtFieldFlat.get_mask">
<span class="sig-name descname"><span class="pre">get_mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.field.NmtFieldFlat.get_mask" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns this fieldâs mask as a 2D array ([ny][nx]).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>2D mask.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.field.NmtFieldFlat.get_templates">
<span class="sig-name descname"><span class="pre">get_templates</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.field.NmtFieldFlat.get_templates" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns a 4D array ([ntemp][nmap][ny][nx]) corresponding to the         contaminant templates passed when initializing this field.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>4D array of flat-sky maps</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-pymaster.bins"></span><dl class="py class">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymaster.bins.</span></span><span class="sig-name descname"><span class="pre">NmtBin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nside</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bpws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nlb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_Dell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_ell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An NmtBin object defines the set of bandpowers used in the     computation of the pseudo-Cl estimator. The definition of     bandpowers is described in Section 3.6 of the scientific     documentation. We provide several convenience constructors
that cover a range of common use cases requiring fewer
parameters (see <a class="reference internal" href="#pymaster.bins.NmtBin.from_nside_linear" title="pymaster.bins.NmtBin.from_nside_linear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">NmtBin.from_nside_linear()</span></code></a>,
<a class="reference internal" href="#pymaster.bins.NmtBin.from_lmax_linear" title="pymaster.bins.NmtBin.from_lmax_linear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">NmtBin.from_lmax_linear()</span></code></a> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Nmt.from_edges()</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nside</strong> (<em>int</em>) â HEALPix nside resolution parameter of the         maps you intend to correlate. The maximum multipole         considered for bandpowers will be 3*nside-1, unless         <cite>lmax</cite> is set.</p></li>
<li><p><strong>ells</strong> (<em>array-like</em>) â array of integers corresponding to         different multipoles</p></li>
<li><p><strong>bpws</strong> (<em>array-like</em>) â array of integers that assign the         multipoles in ells to different bandpowers. All negative         values will be ignored.</p></li>
<li><p><strong>weights</strong> (<em>array-like</em>) â array of floats corresponding to         the weights associated to each multipole in ells. The sum         of weights within each bandpower is normalized to 1.</p></li>
<li><p><strong>nlb</strong> (<em>int</em>) â integer value corresponding to a constant         bandpower width. I.e. the bandpowers will be defined as         consecutive sets of nlb multipoles from l=2 to l=lmax (see         below) with equal weights. If this argument is provided,         the values of ells, bpws and weights are ignored.</p></li>
<li><p><strong>lmax</strong> (<em>int</em>) â integer value corresponding to the maximum         multipole used by these bandpowers. If None, it will be set         to 3*nside-1. In any case the actual maximum multipole will         be chosen as the minimum of lmax, 3*nside-1 and the maximum         element of ells (e.g. if you are using CAR maps and donât         care about nside, you can pass whatever lmax you want and         e.g. nside=lmax).</p></li>
<li><p><strong>is_Dell</strong> (<em>boolean</em>) â if True, the output of all pseudo-Cl         computations carried out using this bandpower scheme (e.g.         from <a class="reference internal" href="#pymaster.workspaces.NmtWorkspace.decouple_cell" title="pymaster.workspaces.NmtWorkspace.decouple_cell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pymaster.workspaces.NmtWorkspace.decouple_cell()</span></code></a>)         will be multiplied by <cite>ell * (ell + 1) / 2 * PI</cite>, where <cite>ell</cite>         is the multipole order (no prefactor otherwise).</p></li>
<li><p><strong>f_ell</strong> (<em>array-like</em>) â if present, this is array represents an         <cite>ell-dependent</cite> function that will be multiplied by all         pseudo-Cl computations carried out using this bandpower scheme.         If not <cite>None</cite>, the value of <cite>is_Dell</cite> is ignored.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.bin_cell">
<span class="sig-name descname"><span class="pre">bin_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls_in</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.bin_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bins a power spectrum into bandpowers. This is carried out as a         weighted average over the multipoles in each bandpower.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cls_in</strong> (<em>array-like</em>) â 2D array of power spectra</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array of bandpowers</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.from_edges">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ell_ini</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell_end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_Dell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.from_edges" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convenience constructor for general equal-weight bands.
All ells in the interval [ell_ini, ell_end) will be
binned with equal weights across the band.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ell_ini</strong> (<em>int</em>) â array containing the lower edges of each
bandpower.</p></li>
<li><p><strong>ell_end</strong> (<em>int</em>) â array containing the upper edges of each
bandpower.</p></li>
<li><p><strong>is_Dell</strong> (<em>boolean</em>) â if True, the output of all pseudo-Cl             computations carried out using this bandpower scheme (e.g.             from <a class="reference internal" href="#pymaster.workspaces.NmtWorkspace.decouple_cell" title="pymaster.workspaces.NmtWorkspace.decouple_cell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pymaster.workspaces.NmtWorkspace.decouple_cell()</span></code></a>)             will be multiplied by <cite>ell * (ell + 1) / 2 * PI</cite>, where <cite>ell</cite>             is the multipole order (no prefactor otherwise).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.from_lmax_linear">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_lmax_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nlb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_Dell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.from_lmax_linear" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convenience constructor for generic linear binning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lmax</strong> (<em>int</em>) â integer value corresponding to the maximum             multipole used by these bandpowers.</p></li>
<li><p><strong>nlb</strong> (<em>int</em>) â integer value corresponding to a constant             bandpower width. I.e. the bandpowers will be defined as             consecutive sets of nlb multipoles from l=2 to l=lmax             with equal weights.</p></li>
<li><p><strong>is_Dell</strong> (<em>boolean</em>) â if True, the output of all pseudo-Cl             computations carried out using this bandpower scheme (e.g.             from <a class="reference internal" href="#pymaster.workspaces.NmtWorkspace.decouple_cell" title="pymaster.workspaces.NmtWorkspace.decouple_cell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pymaster.workspaces.NmtWorkspace.decouple_cell()</span></code></a>)             will be multiplied by <cite>ell * (ell + 1) / 2 * PI</cite>, where <cite>ell</cite>             is the multipole order (no prefactor otherwise).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.from_nside_linear">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_nside_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nside</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nlb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_Dell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.from_nside_linear" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convenience constructor for HEALPix maps with linear binning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nside</strong> (<em>int</em>) â HEALPix nside resolution parameter of the             maps you intend to correlate. The maximum multipole             considered for bandpowers will be 3*nside-1.</p></li>
<li><p><strong>nlb</strong> (<em>int</em>) â integer value corresponding to a constant             bandpower width. I.e. the bandpowers will be defined as             consecutive sets of nlb multipoles from l=2 to l=lmax             with equal weights.</p></li>
<li><p><strong>is_Dell</strong> (<em>boolean</em>) â if True, the output of all pseudo-Cl             computations carried out using this bandpower scheme (e.g.             from <a class="reference internal" href="#pymaster.workspaces.NmtWorkspace.decouple_cell" title="pymaster.workspaces.NmtWorkspace.decouple_cell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pymaster.workspaces.NmtWorkspace.decouple_cell()</span></code></a>)             will be multiplied by <cite>ell * (ell + 1) / 2 * PI</cite>, where <cite>ell</cite>             is the multipole order (no prefactor otherwise).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.get_effective_ells">
<span class="sig-name descname"><span class="pre">get_effective_ells</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.get_effective_ells" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns an array with the effective multipole associated to each         bandpower. These are computed as a weighted average of the         multipoles within each bandpower.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>effective multipoles for each bandpower</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.get_ell_list">
<span class="sig-name descname"><span class="pre">get_ell_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ibin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.get_ell_list" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns an array with the multipoles in the ibin-th bandpower</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ibin</strong> (<em>int</em>) â bandpower index</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>multipoles associated with bandpower ibin</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.get_ell_max">
<span class="sig-name descname"><span class="pre">get_ell_max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.get_ell_max" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the maximum ell value used by bandpower with         index b</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>maximum ell value</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.get_ell_min">
<span class="sig-name descname"><span class="pre">get_ell_min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.get_ell_min" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the minimum ell value used by bandpower with         index b</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>minimum ell value</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.get_n_bands">
<span class="sig-name descname"><span class="pre">get_n_bands</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.get_n_bands" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the number of bandpowers stored in this object</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of bandpowers</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.get_nell_list">
<span class="sig-name descname"><span class="pre">get_nell_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.get_nell_list" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns an array with the number of multipoles in each         bandpower stored in this object</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of multipoles per bandpower</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.get_weight_list">
<span class="sig-name descname"><span class="pre">get_weight_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ibin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.get_weight_list" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns an array with the weights associated to each multipole         in the ibin-th bandpower</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ibin</strong> (<em>int</em>) â bandpower index</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>weights associated to multipoles in bandpower ibin</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBin.unbin_cell">
<span class="sig-name descname"><span class="pre">unbin_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls_in</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBin.unbin_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Un-bins a set of bandpowers into a power spectrum. This is simply         done by assigning a constant value for every multipole in each         bandpower (corresponding to the value of that bandpower).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cls_in</strong> (<em>array-like</em>) â array of bandpowers</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array of power spectra</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymaster.bins.NmtBinFlat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymaster.bins.</span></span><span class="sig-name descname"><span class="pre">NmtBinFlat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBinFlat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An NmtBinFlat object defines the set of bandpowers used in the     computation of the pseudo-Cl estimator. The definition of     bandpowers is described in Section 3.6 of the scientific     documentation. Note that currently pymaster only supports     top-hat bandpowers for flat-sky power spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l0</strong> (<em>array-like</em>) â array of floats corresponding to the         lower bound of each bandpower.</p></li>
<li><p><strong>lf</strong> (<em>array-like</em>) â array of floats corresponding to the         upper bound of each bandpower. lf should have the same         shape as l0</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBinFlat.bin_cell">
<span class="sig-name descname"><span class="pre">bin_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls_in</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBinFlat.bin_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bins a power spectrum into bandpowers. This is carried out         as a weighted average over the multipoles in each bandpower.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ells</strong> (<em>array-like</em>) â multipole values at which the input             power spectra are defined</p></li>
<li><p><strong>cls_in</strong> (<em>array-like</em>) â 2D array of input power spectra</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array of bandpowers</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBinFlat.get_effective_ells">
<span class="sig-name descname"><span class="pre">get_effective_ells</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBinFlat.get_effective_ells" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns an array with the effective multipole associated to         each bandpower. These are computed as a weighted average of         the multipoles within each bandpower.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>effective multipoles for each bandpower</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBinFlat.get_n_bands">
<span class="sig-name descname"><span class="pre">get_n_bands</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBinFlat.get_n_bands" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the number of bandpowers stored in this object</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of bandpowers</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.bins.NmtBinFlat.unbin_cell">
<span class="sig-name descname"><span class="pre">unbin_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ells</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.bins.NmtBinFlat.unbin_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Un-bins a set of bandpowers into a power spectrum. This is         simply done by assigning a constant value for every multipole         in each bandpower (corresponding to the value of that bandpower).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cls_in</strong> (<em>array-like</em>) â array of bandpowers</p></li>
<li><p><strong>ells</strong> (<em>array-like</em>) â array of multipoles at which the power             spectra should be intepolated</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array of power spectra</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-pymaster.workspaces"></span><dl class="py class">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymaster.workspaces.</span></span><span class="sig-name descname"><span class="pre">NmtWorkspace</span></span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspace" title="Permalink to this definition">Â¶</a></dt>
<dd><p>NmtWorkspace objects are used to compute and store the coupling     matrix associated with an incomplete sky coverage, and used in the     MASTER algorithm. When initialized, this object is practically     empty. The information describing the coupling matrix must be     computed or read from a file afterwards.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspace.compute_coupling_matrix">
<span class="sig-name descname"><span class="pre">compute_coupling_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fl1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fl2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_teb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lmax_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_toeplitz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dl_band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspace.compute_coupling_matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes coupling matrix associated with the cross-power spectrum         of two NmtFields and an NmtBin binning scheme. Note that the mode         coupling matrix will only contain ells up to the maximum multipole         included in the NmtBin bandpowers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fl1</strong><strong>,</strong><strong>fl2</strong> (<a class="reference internal" href="#pymaster.field.NmtField" title="pymaster.field.NmtField"><em>NmtField</em></a>) â fields to correlate</p></li>
<li><p><strong>bin</strong> (<a class="reference internal" href="#pymaster.bins.NmtBin" title="pymaster.bins.NmtBin"><em>NmtBin</em></a>) â binning scheme</p></li>
<li><p><strong>is_teb</strong> (<em>boolean</em>) â if true, all mode-coupling matrices             (0-0,0-2,2-2) will be computed at the same time. In this case,             fl1 must be a spin-0 field and fl1 must be spin-2.</p></li>
<li><p><strong>n_iter</strong> â number of iterations when computing a_lms.</p></li>
<li><p><strong>lmax_mask</strong> â maximum multipole for masks. If smaller than the             maximum multipoles of the fields, it will be set to that.</p></li>
<li><p><strong>l_toeplitz</strong> â if a positive number, the Toeplitz approximation             described in Louis et al. 2020 (arXiv:2010.14344) will be used.             In that case, this quantity corresponds to ell_toeplitz in Fig.             3 of that paper.</p></li>
<li><p><strong>l_exact</strong> â if <cite>l_toeplitz&gt;0</cite>, this quantity corresponds to             ell_exact in Fig. 3 of Louis et al. 2020.  Ignored if             <cite>l_toeplitz&lt;=0</cite>.</p></li>
<li><p><strong>dl_band</strong> â if <cite>l_toeplitz&gt;0</cite>, this quantity corresponds to             Delta ell_band in Fig. 3 of Louis et al. 2020.  Ignored if             <cite>l_toeplitz&lt;=0</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspace.couple_cell">
<span class="sig-name descname"><span class="pre">couple_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cl_in</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspace.couple_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convolves a set of input power spectra with a coupling matrix         (see Eq. 6 of the C API documentation).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cl_in</strong> â set of input power spectra. The number of power             spectra must correspond to the spins of the two fields that this             NmtWorkspace object was initialized with (i.e. 1 for two spin-0             fields, 2 for one spin-0 and one spin-2 field and 4 for two             spin-2 fields).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>coupled power spectrum</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspace.decouple_cell">
<span class="sig-name descname"><span class="pre">decouple_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cl_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl_bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspace.decouple_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Decouples a set of pseudo-Cl power spectra into a set of bandpowers         by inverting the binned coupling matrix (se Eq. 4 of the C API         documentation).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cl_in</strong> â set of input power spectra. The number of power spectra             must correspond to the spins of the two fields that this             NmtWorkspace object was initialized with (i.e. 1 for two spin-0             fields, 2 for one spin-0 and one spin-2 field, 4 for two spin-2             fields and 7 if this NmtWorkspace was created using <cite>is_teb=True</cite>).</p></li>
<li><p><strong>cl_bias</strong> â bias to the power spectrum associated to contaminant             residuals (optional). This can be computed through             <code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.deprojection_bias()</span></code>.</p></li>
<li><p><strong>cl_noise</strong> â noise bias (i.e. angular power spectrum of masked             noise realizations).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>set of decoupled bandpowers</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspace.get_bandpower_windows">
<span class="sig-name descname"><span class="pre">get_bandpower_windows</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspace.get_bandpower_windows" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get bandpower window functions. Convolve the theory power spectra         with these as an alternative to the combination         <cite>decouple_cell(couple_cell(</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>bandpower windows with shape             <cite>[n_cls, n_bpws, n_cls, lmax+1]</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspace.get_coupling_matrix">
<span class="sig-name descname"><span class="pre">get_coupling_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspace.get_coupling_matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the currently stored mode-coupling matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>mode-coupling matrix. The matrix will have shape             <cite>[nrows,nrows]</cite>, with <cite>nrows = n_cls * n_ells</cite>, where             <cite>n_cls</cite> is the number of power spectra (1, 2 or 4 for             spin0-0, spin0-2 and spin2-2 correlations) and             <cite>n_ells = lmax + 1</cite> (normally <cite>lmax = 3 * nside - 1</cite>).             The assumed ordering of power spectra is such that the             <cite>l</cite>-th element of the <cite>i</cite>-th power spectrum be stored             with index <cite>l * n_cls + i</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspace.read_from">
<span class="sig-name descname"><span class="pre">read_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">read_unbinned_MCM</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspace.read_from" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Reads the contents of an NmtWorkspace object from a FITS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) â input file name</p></li>
<li><p><strong>read_unbinned_MCM</strong> (<em>bool</em>) â if False, unbinned mode-coupling             matrix will not be read. This can save significant IO time.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspace.update_coupling_matrix">
<span class="sig-name descname"><span class="pre">update_coupling_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspace.update_coupling_matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Updates the stored mode-coupling matrix.</p>
<p>The new matrix (<cite>new_matrix</cite>) must have shape <cite>[nrows,nrows]</cite>,         with <cite>nrows = n_cls * n_ells</cite>, where <cite>n_cls</cite> is the number of         power spectra (1, 2 or 4 for spin0-0, spin0-2 and spin2-2         correlations) and <cite>n_ells = lmax + 1</cite> (normally         <cite>lmax = 3 * nside - 1</cite>). The assumed ordering of power spectra         is such that the <cite>l</cite>-th element of the <cite>i</cite>-th power spectrum be         stored with index <cite>l * n_cls + i</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>new_matrix</strong> â matrix that will replace the mode-coupling matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspace.write_to">
<span class="sig-name descname"><span class="pre">write_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspace.write_to" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Writes the contents of an NmtWorkspace object to a FITS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) â output file name</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspaceFlat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymaster.workspaces.</span></span><span class="sig-name descname"><span class="pre">NmtWorkspaceFlat</span></span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspaceFlat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>NmtWorkspaceFlat objects are used to compute and store the coupling     matrix associated with an incomplete sky coverage, and used in the     flat-sky version of the MASTER algorithm. When initialized, this     object is practically empty. The information describing the coupling     matrix must be computed or read from a file afterwards.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspaceFlat.compute_coupling_matrix">
<span class="sig-name descname"><span class="pre">compute_coupling_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fl1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fl2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell_cut_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1.0,</span> <span class="pre">-</span> <span class="pre">1.0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell_cut_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1.0,</span> <span class="pre">-</span> <span class="pre">1.0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_teb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspaceFlat.compute_coupling_matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes coupling matrix associated with the cross-power spectrum of         two NmtFieldFlats and an NmtBinFlat binning scheme.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fl1</strong><strong>,</strong><strong>fl2</strong> (<a class="reference internal" href="#pymaster.field.NmtFieldFlat" title="pymaster.field.NmtFieldFlat"><em>NmtFieldFlat</em></a>) â fields to correlate</p></li>
<li><p><strong>bin</strong> (<a class="reference internal" href="#pymaster.bins.NmtBinFlat" title="pymaster.bins.NmtBinFlat"><em>NmtBinFlat</em></a>) â binning scheme</p></li>
<li><p><strong>ell_cut_x</strong> (<em>float</em><em>(</em><em>2</em><em>)</em>) â remove all modes with ell_x in the             interval [ell_cut_x[0],ell_cut_x[1]] from the calculation.</p></li>
<li><p><strong>ell_cut_y</strong> (<em>float</em><em>(</em><em>2</em><em>)</em>) â remove all modes with ell_y in the             interval [ell_cut_y[0],ell_cut_y[1]] from the calculation.</p></li>
<li><p><strong>is_teb</strong> (<em>boolean</em>) â if true, all mode-coupling matrices             (0-0,0-2,2-2) will be computed at the same time. In this             case, fl1 must be a spin-0 field and fl1 must be spin-2.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspaceFlat.couple_cell">
<span class="sig-name descname"><span class="pre">couple_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl_in</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspaceFlat.couple_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convolves a set of input power spectra with a coupling matrix         (see Eq. 6 of the C API documentation).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ells</strong> â list of multipoles on which the input power             spectra are defined</p></li>
<li><p><strong>cl_in</strong> â set of input power spectra. The number of power             spectra must correspond to the spins of the two fields that             this NmtWorkspaceFlat object was initialized with (i.e. 1             for two spin-0 fields, 2 for one spin-0 and one spin-2 field             and 4 for two spin-2 fields).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>coupled power spectrum. The coupled power spectra are             returned at the multipoles returned by calling             <code class="xref py py-func docutils literal notranslate"><span class="pre">get_ell_sampling()</span></code> for any of the fields that were used             to generate the workspace.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspaceFlat.decouple_cell">
<span class="sig-name descname"><span class="pre">decouple_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cl_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl_bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspaceFlat.decouple_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Decouples a set of pseudo-Cl power spectra into a set of         bandpowers by inverting the binned coupling matrix (se         Eq. 4 of the C API documentation).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cl_in</strong> â set of input power spectra. The number of power             spectra must correspond to the spins of the two fields that             this NmtWorkspaceFlat object was initialized with (i.e. 1 for             two spin-0 fields, 2 for one spin-0 and one spin-2 field, 4             for two spin-2 fields and 7 if this NmtWorkspaceFlat was             created using <cite>is_teb=True</cite>). These power spectra must be             defined at the multipoles returned by <code class="xref py py-func docutils literal notranslate"><span class="pre">get_ell_sampling()</span></code>             for any of the fields used to create the workspace.</p></li>
<li><p><strong>cl_bias</strong> â bias to the power spectrum associated to             contaminant residuals (optional). This can be computed through             <code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.deprojection_bias_flat()</span></code>.</p></li>
<li><p><strong>cl_noise</strong> â noise bias (i.e. angular power spectrum of masked             noise realizations).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>set of decoupled bandpowers</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspaceFlat.read_from">
<span class="sig-name descname"><span class="pre">read_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspaceFlat.read_from" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Reads the contents of an NmtWorkspaceFlat object from a FITS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) â input file name</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.workspaces.NmtWorkspaceFlat.write_to">
<span class="sig-name descname"><span class="pre">write_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.NmtWorkspaceFlat.write_to" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Writes the contents of an NmtWorkspaceFlat object to a FITS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) â output file name</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.workspaces.compute_coupled_cell">
<span class="sig-prename descclassname"><span class="pre">pymaster.workspaces.</span></span><span class="sig-name descname"><span class="pre">compute_coupled_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.compute_coupled_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes the full-sky angular power spectra of two masked fields     (f1 and f2) without aiming to deconvolve the mode-coupling matrix.     Effectively, this is equivalent to calling the usual HEALPix     anafast routine on the masked and contaminant-cleaned maps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f1</strong><strong>,</strong><strong>f2</strong> (<a class="reference internal" href="#pymaster.field.NmtField" title="pymaster.field.NmtField"><em>NmtField</em></a>) â fields to correlate</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array of coupled power spectra</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.workspaces.compute_coupled_cell_flat">
<span class="sig-prename descclassname"><span class="pre">pymaster.workspaces.</span></span><span class="sig-name descname"><span class="pre">compute_coupled_cell_flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell_cut_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1.0,</span> <span class="pre">-</span> <span class="pre">1.0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell_cut_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1.0,</span> <span class="pre">-</span> <span class="pre">1.0]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.compute_coupled_cell_flat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes the angular power spectra of two masked flat-sky fields     (f1 and f2) without aiming to deconvolve the mode-coupling matrix.     Effectively, this is equivalent to computing the map FFTs and     averaging over rings of wavenumber.  The returned power spectrum     is defined at the multipoles returned by the method     <code class="xref py py-func docutils literal notranslate"><span class="pre">get_ell_sampling()</span></code> of either f1 or f2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f1</strong><strong>,</strong><strong>f2</strong> (<a class="reference internal" href="#pymaster.field.NmtFieldFlat" title="pymaster.field.NmtFieldFlat"><em>NmtFieldFlat</em></a>) â fields to correlate</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pymaster.bins.NmtBinFlat" title="pymaster.bins.NmtBinFlat"><em>NmtBinFlat</em></a>) â binning scheme defining output bandpower</p></li>
<li><p><strong>ell_cut_x</strong> (<em>float</em><em>(</em><em>2</em><em>)</em>) â remove all modes with ell_x in the         interval [ell_cut_x[0],ell_cut_x[1]] from the calculation.</p></li>
<li><p><strong>ell_cut_y</strong> (<em>float</em><em>(</em><em>2</em><em>)</em>) â remove all modes with ell_y in the         interval [ell_cut_y[0],ell_cut_y[1]] from the calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array of coupled power spectra</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.workspaces.compute_full_master">
<span class="sig-prename descclassname"><span class="pre">pymaster.workspaces.</span></span><span class="sig-name descname"><span class="pre">compute_full_master</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl_guess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">workspace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lmax_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_toeplitz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dl_band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.compute_full_master" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes the full MASTER estimate of the power spectrum of two     fields (f1 and f2). This is equivalent to successively calling:</p>
<ul class="simple">
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.NmtWorkspace.compute_coupling_matrix()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.deprojection_bias()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.compute_coupled_cell()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.NmtWorkspace.decouple_cell()</span></code></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f1</strong><strong>,</strong><strong>f2</strong> (<a class="reference internal" href="#pymaster.field.NmtField" title="pymaster.field.NmtField"><em>NmtField</em></a>) â fields to correlate</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pymaster.bins.NmtBin" title="pymaster.bins.NmtBin"><em>NmtBin</em></a>) â binning scheme defining output bandpower</p></li>
<li><p><strong>cl_noise</strong> â noise bias (i.e. angular power spectrum of         masked noise realizations) (optional).</p></li>
<li><p><strong>cl_guess</strong> â set of power spectra corresponding to a         best-guess of the true power spectra of f1 and f2. Needed         only to compute the contaminant cleaning bias (optional).</p></li>
<li><p><strong>workspace</strong> (<a class="reference internal" href="#pymaster.workspaces.NmtWorkspace" title="pymaster.workspaces.NmtWorkspace"><em>NmtWorkspace</em></a>) â object containing the mode-coupling         matrix associated with an incomplete sky coverage. If         provided, the function will skip the computation of the         mode-coupling matrix and use the information encoded in this         object.</p></li>
<li><p><strong>n_iter</strong> â number of iterations when computing a_lms.</p></li>
<li><p><strong>lmax_mask</strong> â maximum multipole for masks. If smaller than the         maximum multipoles of the fields, it will be set to that.</p></li>
<li><p><strong>l_toeplitz</strong> â if a positive number, the Toeplitz approximation         described in Louis et al. 2020 (arXiv:2010.14344) will be used.         In that case, this quantity corresponds to ell_toeplitz in Fig.         3 of that paper.</p></li>
<li><p><strong>l_exact</strong> â if <cite>l_toeplitz&gt;0</cite>, this quantity corresponds to         ell_exact in Fig. 3 of Louis et al. 2020.  Ignored if         <cite>l_toeplitz&lt;=0</cite>.</p></li>
<li><p><strong>dl_band</strong> â if <cite>l_toeplitz&gt;0</cite>, this quantity corresponds to         Delta ell_band in Fig. 3 of Louis et al. 2020.  Ignored if         <cite>l_toeplitz&lt;=0</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>set of decoupled bandpowers</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.workspaces.compute_full_master_flat">
<span class="sig-prename descclassname"><span class="pre">pymaster.workspaces.</span></span><span class="sig-name descname"><span class="pre">compute_full_master_flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl_guess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ells_guess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">workspace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell_cut_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1.0,</span> <span class="pre">-</span> <span class="pre">1.0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell_cut_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1.0,</span> <span class="pre">-</span> <span class="pre">1.0]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.compute_full_master_flat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes the full MASTER estimate of the power spectrum of two flat-sky     fields (f1 and f2). This is equivalent to successively calling:</p>
<ul class="simple">
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.NmtWorkspaceFlat.compute_coupling_matrix()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.deprojection_bias_flat()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.compute_coupled_cell_flat()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">pymaster.NmtWorkspaceFlat.decouple_cell()</span></code></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f1</strong><strong>,</strong><strong>f2</strong> (<a class="reference internal" href="#pymaster.field.NmtFieldFlat" title="pymaster.field.NmtFieldFlat"><em>NmtFieldFlat</em></a>) â fields to correlate</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pymaster.bins.NmtBinFlat" title="pymaster.bins.NmtBinFlat"><em>NmtBinFlat</em></a>) â binning scheme defining output bandpower</p></li>
<li><p><strong>cl_noise</strong> â noise bias (i.e. angular power spectrum of masked noise         realizations) (optional).  This power spectrum should correspond to         the bandpowers defined by b.</p></li>
<li><p><strong>cl_guess</strong> â set of power spectra corresponding to a best-guess of         the true power spectra of f1 and f2. Needed only to compute the         contaminant cleaning bias (optional).</p></li>
<li><p><strong>ells_guess</strong> â multipoles at which cl_guess is defined.</p></li>
<li><p><strong>workspace</strong> (<a class="reference internal" href="#pymaster.workspaces.NmtWorkspaceFlat" title="pymaster.workspaces.NmtWorkspaceFlat"><em>NmtWorkspaceFlat</em></a>) â object containing the mode-coupling         matrix associated with an incomplete sky coverage. If provided, the         function will skip the computation of the mode-coupling matrix and         use the information encoded in this object.</p></li>
<li><p><strong>nell_rebin</strong> (<em>int</em>) â number of sub-intervals into which the base         k-intervals will be sub-sampled to compute the coupling matrix</p></li>
<li><p><strong>ell_cut_x</strong> (<em>float</em><em>(</em><em>2</em><em>)</em>) â remove all modes with ell_x in the interval         [ell_cut_x[0],ell_cut_x[1]] from the calculation.</p></li>
<li><p><strong>ell_cut_y</strong> (<em>float</em><em>(</em><em>2</em><em>)</em>) â remove all modes with ell_y in the interval         [ell_cut_y[0],ell_cut_y[1]] from the calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>set of decoupled bandpowers</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.workspaces.deprojection_bias">
<span class="sig-prename descclassname"><span class="pre">pymaster.workspaces.</span></span><span class="sig-name descname"><span class="pre">deprojection_bias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls_guess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.deprojection_bias" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes the bias associated to contaminant removal to the     cross-pseudo-Cl of two fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f1</strong><strong>,</strong><strong>f2</strong> (<a class="reference internal" href="#pymaster.field.NmtField" title="pymaster.field.NmtField"><em>NmtField</em></a>) â fields to correlate</p></li>
<li><p><strong>cls_guess</strong> â set of power spectra corresponding to a         best-guess of the true power spectra of f1 and f2.</p></li>
<li><p><strong>n_iter</strong> â number of iterations when computing a_lms.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>deprojection bias power spectra.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.workspaces.deprojection_bias_flat">
<span class="sig-prename descclassname"><span class="pre">pymaster.workspaces.</span></span><span class="sig-name descname"><span class="pre">deprojection_bias_flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls_guess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell_cut_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1.0,</span> <span class="pre">-</span> <span class="pre">1.0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ell_cut_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1.0,</span> <span class="pre">-</span> <span class="pre">1.0]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.deprojection_bias_flat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes the bias associated to contaminant removal to the     cross-pseudo-Cl of two flat-sky fields. The returned power     spectrum is defined at the multipoles returned by the method     <code class="xref py py-func docutils literal notranslate"><span class="pre">get_ell_sampling()</span></code> of either f1 or f2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f1</strong><strong>,</strong><strong>f2</strong> (<a class="reference internal" href="#pymaster.field.NmtFieldFlat" title="pymaster.field.NmtFieldFlat"><em>NmtFieldFlat</em></a>) â fields to correlate</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="#pymaster.bins.NmtBinFlat" title="pymaster.bins.NmtBinFlat"><em>NmtBinFlat</em></a>) â binning scheme defining output bandpower</p></li>
<li><p><strong>ells</strong> â list of multipoles on which the proposal power         spectra are defined</p></li>
<li><p><strong>cls_guess</strong> â set of power spectra corresponding to a         best-guess of the true power spectra of f1 and f2.</p></li>
<li><p><strong>ell_cut_x</strong> (<em>float</em><em>(</em><em>2</em><em>)</em>) â remove all modes with ell_x in the         interval [ell_cut_x[0],ell_cut_x[1]] from the calculation.</p></li>
<li><p><strong>ell_cut_y</strong> (<em>float</em><em>(</em><em>2</em><em>)</em>) â remove all modes with ell_y in the         interval [ell_cut_y[0],ell_cut_y[1]] from the calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>deprojection bias power spectra.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.workspaces.uncorr_noise_deprojection_bias">
<span class="sig-prename descclassname"><span class="pre">pymaster.workspaces.</span></span><span class="sig-name descname"><span class="pre">uncorr_noise_deprojection_bias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.workspaces.uncorr_noise_deprojection_bias" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes the bias associated to contaminant removal in the presence     of uncorrelated inhomogeneous noise to the auto-pseudo-Cl of a     given field f1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f1</strong> (<a class="reference internal" href="#pymaster.field.NmtField" title="pymaster.field.NmtField"><em>NmtField</em></a>) â fields to correlate</p></li>
<li><p><strong>map_cls_guess</strong> â array containing a HEALPix map corresponding         to the local noise variance (in one sterad).</p></li>
<li><p><strong>n_iter</strong> â number of iterations when computing a_lms.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>deprojection bias power spectra.</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-pymaster.covariance"></span><dl class="py class">
<dt class="sig sig-object py" id="pymaster.covariance.NmtCovarianceWorkspace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymaster.covariance.</span></span><span class="sig-name descname"><span class="pre">NmtCovarianceWorkspace</span></span><a class="headerlink" href="#pymaster.covariance.NmtCovarianceWorkspace" title="Permalink to this definition">Â¶</a></dt>
<dd><p>NmtCovarianceWorkspace objects are used to compute and store     the coupling coefficients needed to calculate the Gaussian     covariance matrix under the approximations in astro-ph/0307515     and arXiv/1609.09730. When initialized, this object is     practically empty. The information describing the coupling     coefficients must be computed or read from a file afterwards.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymaster.covariance.NmtCovarianceWorkspace.compute_coupling_coefficients">
<span class="sig-name descname"><span class="pre">compute_coupling_coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fla1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fla2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flb1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flb2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_toeplitz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dl_band</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin0_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.covariance.NmtCovarianceWorkspace.compute_coupling_coefficients" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes coupling coefficients of the Gaussian covariance         between the power spectra of two pairs of NmtField objects         (fla1, fla2, flb1 and flb2). Note that you can reuse this         workspace for the covariance of power spectra between any         pairs of fields as long as the fields have the same masks         as those passed to this function, and as long as the binning         scheme used are also the same.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fla1</strong><strong>,</strong><strong>fla2</strong> (<a class="reference internal" href="#pymaster.field.NmtField" title="pymaster.field.NmtField"><em>NmtField</em></a>) â fields contributing to the first             power spectrum whose covariance you want to compute.</p></li>
<li><p><strong>flb1</strong><strong>,</strong><strong>flb2</strong> (<a class="reference internal" href="#pymaster.field.NmtField" title="pymaster.field.NmtField"><em>NmtField</em></a>) â fields contributing to the second             power spectrum whose covariance you want to compute. If             None, fla1,fla2 will be used.</p></li>
<li><p><strong>n_iter</strong> â number of iterations when computing a_lms.</p></li>
<li><p><strong>l_toeplitz</strong> â if a positive number, the Toeplitz approximation             described in Louis et al. 2020 (arXiv:2010.14344) will be used.             In that case, this quantity corresponds to ell_toeplitz in Fig.             3 of that paper.</p></li>
<li><p><strong>l_exact</strong> â if <cite>l_toeplitz&gt;0</cite>, this quantity corresponds to             ell_exact in Fig. 3 of Louis et al. 2020.  Ignored if             <cite>l_toeplitz&lt;=0</cite>.</p></li>
<li><p><strong>dl_band</strong> â if <cite>l_toeplitz&gt;0</cite>, this quantity corresponds to             Delta ell_band in Fig. 3 of Louis et al. 2020.  Ignored if             <cite>l_toeplitz&lt;=0</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Spin0_only</dt>
<dd class="field-even"><p>if <cite>True</cite>, only spin-0 combinations of the MCMs will             be computed and stored.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.covariance.NmtCovarianceWorkspace.read_from">
<span class="sig-name descname"><span class="pre">read_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_spin0_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.covariance.NmtCovarianceWorkspace.read_from" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Reads the contents of an NmtCovarianceWorkspace object         from a FITS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) â input file name</p></li>
<li><p><strong>force_spin0_only</strong> (<em>bool</em>) â if <cite>True</cite>, only spin-0             combinations will be read and stored.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.covariance.NmtCovarianceWorkspace.write_to">
<span class="sig-name descname"><span class="pre">write_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.covariance.NmtCovarianceWorkspace.write_to" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Writes the contents of an NmtCovarianceWorkspace object to a FITS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) â output file name</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymaster.covariance.NmtCovarianceWorkspaceFlat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymaster.covariance.</span></span><span class="sig-name descname"><span class="pre">NmtCovarianceWorkspaceFlat</span></span><a class="headerlink" href="#pymaster.covariance.NmtCovarianceWorkspaceFlat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>NmtCovarianceWorkspaceFlat objects are used to compute and store the     coupling coefficients needed to calculate the Gaussian covariance     matrix under a flat-sky version the Efstathiou approximations in     astro-ph/0307515 and arXiv/1609.09730. When initialized, this object     is practically empty. The information describing the coupling     coefficients must be computed or read from a file afterwards.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymaster.covariance.NmtCovarianceWorkspaceFlat.compute_coupling_coefficients">
<span class="sig-name descname"><span class="pre">compute_coupling_coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fla1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fla2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flb1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flb2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.covariance.NmtCovarianceWorkspaceFlat.compute_coupling_coefficients" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes coupling coefficients of the Gaussian covariance between         the power spectra of two pairs of NmtFieldFlat objects (fla1, fla2,         flb1 and flb2). Note that you can reuse this workspace for the         covariance of power spectra between any pairs of fields as long         as the fields have the same masks as those passed to this function,         and as long as the binning scheme used are also the same.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fla1</strong><strong>,</strong><strong>fla2</strong> (<a class="reference internal" href="#pymaster.field.NmtFieldFlat" title="pymaster.field.NmtFieldFlat"><em>NmtFieldFlat</em></a>) â fields contributing to the first             power spectrum whose covariance you want to compute.</p></li>
<li><p><strong>bin_a</strong> (<a class="reference internal" href="#pymaster.bins.NmtBinFlat" title="pymaster.bins.NmtBinFlat"><em>NmtBinFlat</em></a>) â binning scheme for the first power             spectrum.</p></li>
<li><p><strong>flb1</strong><strong>,</strong><strong>flb2</strong> (<a class="reference internal" href="#pymaster.field.NmtFieldFlat" title="pymaster.field.NmtFieldFlat"><em>NmtFieldFlat</em></a>) â fields contributing to the second             power spectrum whose covariance you want to compute. If None,             fla1,fla2 will be used.</p></li>
<li><p><strong>bin_b</strong> (<a class="reference internal" href="#pymaster.bins.NmtBinFlat" title="pymaster.bins.NmtBinFlat"><em>NmtBinFlat</em></a>) â binning scheme for the second power             spectrum. If none, bin_a will be used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.covariance.NmtCovarianceWorkspaceFlat.read_from">
<span class="sig-name descname"><span class="pre">read_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.covariance.NmtCovarianceWorkspaceFlat.read_from" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Reads the contents of an NmtCovarianceWorkspaceFlat object from a         FITS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) â input file name</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymaster.covariance.NmtCovarianceWorkspaceFlat.write_to">
<span class="sig-name descname"><span class="pre">write_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.covariance.NmtCovarianceWorkspaceFlat.write_to" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Writes the contents of an NmtCovarianceWorkspaceFlat object to         a FITS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fname</strong> (<em>str</em>) â output file name</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.covariance.gaussian_covariance">
<span class="sig-prename descclassname"><span class="pre">pymaster.covariance.</span></span><span class="sig-name descname"><span class="pre">gaussian_covariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_b1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_b2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cla1b1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cla1b2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cla2b1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cla2b2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coupled</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.covariance.gaussian_covariance" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes Gaussian covariance matrix for power spectra using the     information precomputed in cw (a NmtCovarianceWorkspace object).     cw should have been initialized using four NmtField objects (letâs     call them a1, a2, b1 and b2), corresponding to the two pairs of     fields whose power spectra we want the covariance of. These power     spectra should have been computed using two NmtWorkspace objects,     wa and wb, which must be passed as arguments of this function (the     power spectrum for fields a1 and a2 was computed with wa, and that     of b1 and b2 with wb). Using the same notation, clXnYm should be a     prediction for the power spectrum between fields Xn and Ym. These     predicted input power spectra should be defined for all     ells &lt;=3*nside (where nside is the HEALPix resolution parameter of     the fields that were correlated).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cw</strong> (<a class="reference internal" href="#pymaster.covariance.NmtCovarianceWorkspace" title="pymaster.covariance.NmtCovarianceWorkspace"><em>NmtCovarianceWorkspace</em></a>) â workspaces containing the         precomputed coupling coefficients.</p></li>
<li><p><strong>spin_Xn</strong> (<em>int</em>) â spin for the n-th field in pair X.</p></li>
<li><p><strong>clXnYm</strong> â prediction for the cross-power spectrum between         fields Xn and Ym.</p></li>
<li><p><strong>wX</strong> (<a class="reference internal" href="#pymaster.workspaces.NmtWorkspace" title="pymaster.workspaces.NmtWorkspace"><em>NmtWorkspace</em></a>) â workspace containing the mode-coupling         matrix pair X. If <cite>wb</cite> is <cite>None</cite>, the code will assume <cite>wb=wa</cite>.</p></li>
<li><p><strong>coupled</strong> â if <cite>True</cite>, the covariance matrix of the
mode-coupled pseudo-Cls will be computed. Otherwise itâll be
the covariance of decoupled bandpowers.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.covariance.gaussian_covariance_flat">
<span class="sig-prename descclassname"><span class="pre">pymaster.covariance.</span></span><span class="sig-name descname"><span class="pre">gaussian_covariance_flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_b1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_b2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">larr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cla1b1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cla1b2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cla2b1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cla2b2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.covariance.gaussian_covariance_flat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Computes Gaussian covariance matrix for flat-sky power spectra using     the information precomputed in cw (a NmtCovarianceWorkspaceFlat object).     cw should have been initialized using four NmtFieldFlat objects (letâs     call them a1, a2, b1 and b2), corresponding to the two pairs of fields     whose power spectra we want the covariance of. These power spectra should     have been computed using two NmtWorkspaceFlat objects, wa and wb, which     must be passed as arguments of this function (the power spectrum for     fields a1 and a2 was computed with wa, and that of b1 and b2 with wb).     Using the same notation, clXnYm should be a prediction for the power     spectrum between fields Xn and Ym. These predicted input power spectra     should be defined in a sufficiently well sampled range of ells given the     map properties from which the power spectra were computed. The values of     ell at which they are sampled are given by larr.</p>
<p>Please note that, while the method used to estimate these covariance     is sufficiently accurate in a large number of scenarios, it is based on     a numerical approximation, and its accuracy should be assessed if in     doubt. In particular, we discourage users from using it to compute any     covariance matrix involving B-mode components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cw</strong> (<a class="reference internal" href="#pymaster.covariance.NmtCovarianceWorkspaceFlat" title="pymaster.covariance.NmtCovarianceWorkspaceFlat"><em>NmtCovarianceWorkspaceFlat</em></a>) â workspaces containing the         precomputed coupling coefficients.</p></li>
<li><p><strong>spin_Xn</strong> (<em>int</em>) â spin for the n-th field in pair X.</p></li>
<li><p><strong>larr</strong> â values of ell at which the following power spectra are         computed.</p></li>
<li><p><strong>clXnYm</strong> â prediction for the cross-power spectrum between fields         Xn and Ym.</p></li>
<li><p><strong>wX</strong> (<a class="reference internal" href="#pymaster.workspaces.NmtWorkspaceFlat" title="pymaster.workspaces.NmtWorkspaceFlat"><em>NmtWorkspaceFlat</em></a>) â workspace containing the mode-coupling matrix         pair X. If <cite>wb</cite> is <cite>None</cite>, the code will assume <cite>wb=wa</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-pymaster.utils"></span><dl class="py class">
<dt class="sig sig-object py" id="pymaster.utils.NmtWCSTranslator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymaster.utils.</span></span><span class="sig-name descname"><span class="pre">NmtWCSTranslator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.utils.NmtWCSTranslator" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This class takes care of interpreting a WCS object in     terms of a Clenshaw-Curtis grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wcs</strong> â a WCS object (see         <a class="reference external" href="http://docs.astropy.org/en/stable/wcs/index.html">http://docs.astropy.org/en/stable/wcs/index.html</a>).</p></li>
<li><p><strong>axes</strong> â shape of the maps you want to analyze.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.utils.mask_apodization">
<span class="sig-prename descclassname"><span class="pre">pymaster.utils.</span></span><span class="sig-name descname"><span class="pre">mask_apodization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aposize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apotype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C1'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.utils.mask_apodization" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Apodizes a mask with an given apodization scale using different methods.     A given pixel is determined to be âmaskedâ if its value is 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask_in</strong> â input mask, provided as an array of floats         corresponding to a HEALPix map in RING order.</p></li>
<li><p><strong>aposize</strong> â apodization scale in degrees.</p></li>
<li><p><strong>apotype</strong> â apodization type. Three methods implemented:         âC1â, âC2â and âSmoothâ. See the description of the C-function         nmt_apodize_mask in the C API documentation for a full description         of these methods.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>apodized mask as a HEALPix map</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.utils.mask_apodization_flat">
<span class="sig-prename descclassname"><span class="pre">pymaster.utils.</span></span><span class="sig-name descname"><span class="pre">mask_apodization_flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aposize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apotype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C1'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.utils.mask_apodization_flat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Apodizes a flat-sky mask with an given apodization scale using     different methods. A given pixel is determined to be âmaskedâ if     its value is 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask_in</strong> â input mask, provided as a 2D array (ny,nx) of floats.</p></li>
<li><p><strong>lx</strong> (<em>float</em>) â patch size in the x-axis (in radians)</p></li>
<li><p><strong>ly</strong> (<em>float</em>) â patch size in the y-axis (in radians)</p></li>
<li><p><strong>aposize</strong> â apodization scale in degrees.</p></li>
<li><p><strong>apotype</strong> â apodization type. Three methods implemented: âC1â,        âC2â and âSmoothâ. See the description of the C-function        nmt_apodize_mask in the C API documentation for a full        description of these methods.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>apodized mask as a 2D array (ny,nx)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.utils.synfast_flat">
<span class="sig-prename descclassname"><span class="pre">pymaster.utils.</span></span><span class="sig-name descname"><span class="pre">synfast_flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ny</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.utils.synfast_flat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Generates a flat-sky Gaussian random field according to a given power     spectrum. This function is the flat-sky equivalent of healpyâs synfast.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> (<em>int</em>) â number of pixels in the x-axis</p></li>
<li><p><strong>ny</strong> (<em>int</em>) â number of pixels in the y-axis</p></li>
<li><p><strong>lx</strong> (<em>float</em>) â patch size in the x-axis (in radians)</p></li>
<li><p><strong>ly</strong> (<em>float</em>) â patch size in the y-axis (in radians)</p></li>
<li><p><strong>cls</strong> (<em>array-like</em>) â array containing power spectra. Shape should be         [n_cls][n_ell], where n_cls is the number of power spectra needed         to define all the fields. This should be         n_cls = n_maps * (n_maps + 1) / 2, where n_maps is the total number         of maps required (1 for each spin-0 field, 2 for each spin&gt;0 field).         Power spectra must be provided only for the upper-triangular part in         row-major order (e.g. if n_maps is 3, there will be 6 power spectra         ordered as [1-1,1-2,1-3,2-2,2-3,3-3].</p></li>
<li><p><strong>spin_arr</strong> (<em>array-like</em>) â array containing the spins of all the fields         to generate.</p></li>
<li><p><strong>array-like</strong> (<em>beam</em>) â 2D array containing the instrumental beam of each         field to simulate (the output map(s) will be convolved with it)</p></li>
<li><p><strong>seed</strong> (<em>int</em>) â RNG seed. If negative, will use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a number of arrays (1 for each spin-0 field, 2 for each         spin-2 field) of size (ny,nx) containing the simulated maps.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymaster.utils.synfast_spherical">
<span class="sig-prename descclassname"><span class="pre">pymaster.utils.</span></span><span class="sig-name descname"><span class="pre">synfast_spherical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nside</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wcs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymaster.utils.synfast_spherical" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Generates a full-sky Gaussian random field according to a given     power spectrum. This function should produce outputs similar to     healpyâs synfast.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nside</strong> (<em>int</em>) â HEALpix resolution parameter. If you want         rectangular pixel maps, ignore this parameter and pass a         WCS object as <cite>wcs</cite> (see below).</p></li>
<li><p><strong>cls</strong> (<em>array-like</em>) â array containing power spectra. Shape         should be [n_cls][n_ell], where n_cls is the number of power         spectra needed to define all the fields. This should be         n_cls = n_maps * (n_maps + 1) / 2, where n_maps is the total         number of maps required (1 for each spin-0 field, 2 for each         spin&gt;0 field). Power spectra must be provided only for the         upper-triangular part in row-major order (e.g. if n_maps is         3, there will be 6 power spectra ordered as         [1-1,1-2,1-3,2-2,2-3,3-3].</p></li>
<li><p><strong>spin_arr</strong> (<em>array-like</em>) â array containing the spins of all the         fields to generate.</p></li>
<li><p><strong>array-like</strong> (<em>beam</em>) â 2D array containing the instrumental beam         of each field to simulate (the output map(s) will be convolved         with it)</p></li>
<li><p><strong>seed</strong> (<em>int</em>) â RNG seed. If negative, will use a random seed.</p></li>
<li><p><strong>wcs</strong> â a WCS object         (see <a class="reference external" href="http://docs.astropy.org/en/stable/wcs/index.html">http://docs.astropy.org/en/stable/wcs/index.html</a>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a number of full-sky maps (1 for each spin-0 field, 2 for         each spin-2 field).</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="sample_simple.html" class="btn btn-neutral float-right" title="Example 1: simple pseudo-Cl computation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017, David Alonso.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>