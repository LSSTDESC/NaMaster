# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    import _nmtlib
else:
    import _nmtlib

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class binning_scheme_flat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n_bands = property(_nmtlib.binning_scheme_flat_n_bands_get, _nmtlib.binning_scheme_flat_n_bands_set)
    ell_0_list = property(_nmtlib.binning_scheme_flat_ell_0_list_get, _nmtlib.binning_scheme_flat_ell_0_list_set)
    ell_f_list = property(_nmtlib.binning_scheme_flat_ell_f_list_get, _nmtlib.binning_scheme_flat_ell_f_list_set)

    def __init__(self):
        _nmtlib.binning_scheme_flat_swiginit(self, _nmtlib.new_binning_scheme_flat())
    __swig_destroy__ = _nmtlib.delete_binning_scheme_flat

# Register binning_scheme_flat in _nmtlib:
_nmtlib.binning_scheme_flat_swigregister(binning_scheme_flat)


def bins_flat_constant(nlb, lmax):
    return _nmtlib.bins_flat_constant(nlb, lmax)

def bins_flat_create(nell, l0, lf):
    return _nmtlib.bins_flat_create(nell, l0, lf)

def bins_flat_free(bin):
    return _nmtlib.bins_flat_free(bin)

def bin_cls_flat(bin, nl, larr, cls_in, cls_out, ncls):
    return _nmtlib.bin_cls_flat(bin, nl, larr, cls_in, cls_out, ncls)

def unbin_cls_flat(bin, cls_in, nl, larr, cls_out, ncls):
    return _nmtlib.unbin_cls_flat(bin, cls_in, nl, larr, cls_out, ncls)

def ell_eff_flat(bin, larr):
    return _nmtlib.ell_eff_flat(bin, larr)

def bins_flat_search_fast(bin, l, il):
    return _nmtlib.bins_flat_search_fast(bin, l, il)
class binning_scheme(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n_bands = property(_nmtlib.binning_scheme_n_bands_get, _nmtlib.binning_scheme_n_bands_set)
    nell_list = property(_nmtlib.binning_scheme_nell_list_get, _nmtlib.binning_scheme_nell_list_set)
    ell_list = property(_nmtlib.binning_scheme_ell_list_get, _nmtlib.binning_scheme_ell_list_set)
    w_list = property(_nmtlib.binning_scheme_w_list_get, _nmtlib.binning_scheme_w_list_set)
    f_ell = property(_nmtlib.binning_scheme_f_ell_get, _nmtlib.binning_scheme_f_ell_set)
    ell_max = property(_nmtlib.binning_scheme_ell_max_get, _nmtlib.binning_scheme_ell_max_set)

    def __init__(self):
        _nmtlib.binning_scheme_swiginit(self, _nmtlib.new_binning_scheme())
    __swig_destroy__ = _nmtlib.delete_binning_scheme

# Register binning_scheme in _nmtlib:
_nmtlib.binning_scheme_swigregister(binning_scheme)


def bins_constant(nlb, lmax, is_l2):
    return _nmtlib.bins_constant(nlb, lmax, is_l2)

def bins_create(nell, bpws, ells, weights, f_ell, lmax):
    return _nmtlib.bins_create(nell, bpws, ells, weights, f_ell, lmax)

def bins_read(fname, lmax):
    return _nmtlib.bins_read(fname, lmax)

def bins_free(bin):
    return _nmtlib.bins_free(bin)

def bin_cls(bin, cls_in, cls_out, ncls):
    return _nmtlib.bin_cls(bin, cls_in, cls_out, ncls)

def unbin_cls(bin, cls_in, cls_out, ncls):
    return _nmtlib.unbin_cls(bin, cls_in, cls_out, ncls)

def ell_eff(bin, larr):
    return _nmtlib.ell_eff(bin, larr)
class k_function(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_const = property(_nmtlib.k_function_is_const_get, _nmtlib.k_function_is_const_set)
    x0 = property(_nmtlib.k_function_x0_get, _nmtlib.k_function_x0_set)
    xf = property(_nmtlib.k_function_xf_get, _nmtlib.k_function_xf_set)
    y0 = property(_nmtlib.k_function_y0_get, _nmtlib.k_function_y0_set)
    yf = property(_nmtlib.k_function_yf_get, _nmtlib.k_function_yf_set)
    spl = property(_nmtlib.k_function_spl_get, _nmtlib.k_function_spl_set)

    def __init__(self):
        _nmtlib.k_function_swiginit(self, _nmtlib.new_k_function())
    __swig_destroy__ = _nmtlib.delete_k_function

# Register k_function in _nmtlib:
_nmtlib.k_function_swigregister(k_function)


def k_function_alloc(nk, karr, farr, y0, yf, is_const):
    return _nmtlib.k_function_alloc(nk, karr, farr, y0, yf, is_const)

def k_function_free(f):
    return _nmtlib.k_function_free(f)

def k_function_eval(f, k, intacc):
    return _nmtlib.k_function_eval(f, k, intacc)
class flatsky_info(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nx = property(_nmtlib.flatsky_info_nx_get, _nmtlib.flatsky_info_nx_set)
    ny = property(_nmtlib.flatsky_info_ny_get, _nmtlib.flatsky_info_ny_set)
    npix = property(_nmtlib.flatsky_info_npix_get, _nmtlib.flatsky_info_npix_set)
    lx = property(_nmtlib.flatsky_info_lx_get, _nmtlib.flatsky_info_lx_set)
    ly = property(_nmtlib.flatsky_info_ly_get, _nmtlib.flatsky_info_ly_set)
    pixsize = property(_nmtlib.flatsky_info_pixsize_get, _nmtlib.flatsky_info_pixsize_set)
    n_ell = property(_nmtlib.flatsky_info_n_ell_get, _nmtlib.flatsky_info_n_ell_set)
    dell = property(_nmtlib.flatsky_info_dell_get, _nmtlib.flatsky_info_dell_set)
    i_dell = property(_nmtlib.flatsky_info_i_dell_get, _nmtlib.flatsky_info_i_dell_set)
    ell_min = property(_nmtlib.flatsky_info_ell_min_get, _nmtlib.flatsky_info_ell_min_set)

    def __init__(self):
        _nmtlib.flatsky_info_swiginit(self, _nmtlib.new_flatsky_info())
    __swig_destroy__ = _nmtlib.delete_flatsky_info

# Register flatsky_info in _nmtlib:
_nmtlib.flatsky_info_swigregister(flatsky_info)


def flatsky_info_alloc(nx, ny, lx, ly):
    return _nmtlib.flatsky_info_alloc(nx, ny, lx, ly)

def flatsky_info_free(fs):
    return _nmtlib.flatsky_info_free(fs)
class field_flat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    fs = property(_nmtlib.field_flat_fs_get, _nmtlib.field_flat_fs_set)
    npix = property(_nmtlib.field_flat_npix_get, _nmtlib.field_flat_npix_set)
    pure_e = property(_nmtlib.field_flat_pure_e_get, _nmtlib.field_flat_pure_e_set)
    pure_b = property(_nmtlib.field_flat_pure_b_get, _nmtlib.field_flat_pure_b_set)
    mask = property(_nmtlib.field_flat_mask_get, _nmtlib.field_flat_mask_set)
    a_mask = property(_nmtlib.field_flat_a_mask_get, _nmtlib.field_flat_a_mask_set)
    spin = property(_nmtlib.field_flat_spin_get, _nmtlib.field_flat_spin_set)
    nmaps = property(_nmtlib.field_flat_nmaps_get, _nmtlib.field_flat_nmaps_set)
    maps = property(_nmtlib.field_flat_maps_get, _nmtlib.field_flat_maps_set)
    alms = property(_nmtlib.field_flat_alms_get, _nmtlib.field_flat_alms_set)
    ntemp = property(_nmtlib.field_flat_ntemp_get, _nmtlib.field_flat_ntemp_set)
    temp = property(_nmtlib.field_flat_temp_get, _nmtlib.field_flat_temp_set)
    a_temp = property(_nmtlib.field_flat_a_temp_get, _nmtlib.field_flat_a_temp_set)
    matrix_M = property(_nmtlib.field_flat_matrix_M_get, _nmtlib.field_flat_matrix_M_set)
    beam = property(_nmtlib.field_flat_beam_get, _nmtlib.field_flat_beam_set)
    lite = property(_nmtlib.field_flat_lite_get, _nmtlib.field_flat_lite_set)
    mask_only = property(_nmtlib.field_flat_mask_only_get, _nmtlib.field_flat_mask_only_set)

    def __init__(self):
        _nmtlib.field_flat_swiginit(self, _nmtlib.new_field_flat())
    __swig_destroy__ = _nmtlib.delete_field_flat

# Register field_flat in _nmtlib:
_nmtlib.field_flat_swigregister(field_flat)


def field_flat_free(fl):
    return _nmtlib.field_flat_free(fl)

def field_flat_alloc(nx, ny, lx, ly, mask, spin, maps, ntemp, temp, nl_beam, l_beam, beam, pure_e, pure_b, tol_pinv, masked_input, is_lite, mask_only):
    return _nmtlib.field_flat_alloc(nx, ny, lx, ly, mask, spin, maps, ntemp, temp, nl_beam, l_beam, beam, pure_e, pure_b, tol_pinv, masked_input, is_lite, mask_only)

def synfast_flat(nx, ny, lx, ly, nfields, spin_arr, nl_beam, l_beam, beam_fields, nl_cell, l_cell, cell_fields, seed):
    return _nmtlib.synfast_flat(nx, ny, lx, ly, nfields, spin_arr, nl_beam, l_beam, beam_fields, nl_cell, l_cell, cell_fields, seed)

def purify_flat(fl, mask, walm0, maps_in, maps_out, alms):
    return _nmtlib.purify_flat(fl, mask, walm0, maps_in, maps_out, alms)
class curvedsky_info(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_healpix = property(_nmtlib.curvedsky_info_is_healpix_get, _nmtlib.curvedsky_info_is_healpix_set)
    n_eq = property(_nmtlib.curvedsky_info_n_eq_get, _nmtlib.curvedsky_info_n_eq_set)
    lmax_sht = property(_nmtlib.curvedsky_info_lmax_sht_get, _nmtlib.curvedsky_info_lmax_sht_set)
    nx_short = property(_nmtlib.curvedsky_info_nx_short_get, _nmtlib.curvedsky_info_nx_short_set)
    nx = property(_nmtlib.curvedsky_info_nx_get, _nmtlib.curvedsky_info_nx_set)
    ny = property(_nmtlib.curvedsky_info_ny_get, _nmtlib.curvedsky_info_ny_set)
    npix = property(_nmtlib.curvedsky_info_npix_get, _nmtlib.curvedsky_info_npix_set)
    Delta_theta = property(_nmtlib.curvedsky_info_Delta_theta_get, _nmtlib.curvedsky_info_Delta_theta_set)
    Delta_phi = property(_nmtlib.curvedsky_info_Delta_phi_get, _nmtlib.curvedsky_info_Delta_phi_set)
    phi0 = property(_nmtlib.curvedsky_info_phi0_get, _nmtlib.curvedsky_info_phi0_set)
    theta0 = property(_nmtlib.curvedsky_info_theta0_get, _nmtlib.curvedsky_info_theta0_set)

    def __init__(self):
        _nmtlib.curvedsky_info_swiginit(self, _nmtlib.new_curvedsky_info())
    __swig_destroy__ = _nmtlib.delete_curvedsky_info

# Register curvedsky_info in _nmtlib:
_nmtlib.curvedsky_info_swigregister(curvedsky_info)


def curvedsky_info_copy(cs_in):
    return _nmtlib.curvedsky_info_copy(cs_in)

def curvedsky_info_alloc(is_healpix, nside, lmax_sht, nx0, ny0, Dtheta, Dphi, phi0, theta0):
    return _nmtlib.curvedsky_info_alloc(is_healpix, nside, lmax_sht, nx0, ny0, Dtheta, Dphi, phi0, theta0)

def diff_curvedsky_info(c1, c2):
    return _nmtlib.diff_curvedsky_info(c1, c2)

def extend_CAR_map(cs, map_in):
    return _nmtlib.extend_CAR_map(cs, map_in)
class field(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cs = property(_nmtlib.field_cs_get, _nmtlib.field_cs_set)
    npix = property(_nmtlib.field_npix_get, _nmtlib.field_npix_set)
    nalms = property(_nmtlib.field_nalms_get, _nmtlib.field_nalms_set)
    lmax = property(_nmtlib.field_lmax_get, _nmtlib.field_lmax_set)
    pure_e = property(_nmtlib.field_pure_e_get, _nmtlib.field_pure_e_set)
    pure_b = property(_nmtlib.field_pure_b_get, _nmtlib.field_pure_b_set)
    mask = property(_nmtlib.field_mask_get, _nmtlib.field_mask_set)
    a_mask = property(_nmtlib.field_a_mask_get, _nmtlib.field_a_mask_set)
    spin = property(_nmtlib.field_spin_get, _nmtlib.field_spin_set)
    nmaps = property(_nmtlib.field_nmaps_get, _nmtlib.field_nmaps_set)
    maps = property(_nmtlib.field_maps_get, _nmtlib.field_maps_set)
    alms = property(_nmtlib.field_alms_get, _nmtlib.field_alms_set)
    ntemp = property(_nmtlib.field_ntemp_get, _nmtlib.field_ntemp_set)
    temp = property(_nmtlib.field_temp_get, _nmtlib.field_temp_set)
    a_temp = property(_nmtlib.field_a_temp_get, _nmtlib.field_a_temp_set)
    matrix_M = property(_nmtlib.field_matrix_M_get, _nmtlib.field_matrix_M_set)
    beam = property(_nmtlib.field_beam_get, _nmtlib.field_beam_set)
    lite = property(_nmtlib.field_lite_get, _nmtlib.field_lite_set)
    mask_only = property(_nmtlib.field_mask_only_get, _nmtlib.field_mask_only_set)

    def __init__(self):
        _nmtlib.field_swiginit(self, _nmtlib.new_field())
    __swig_destroy__ = _nmtlib.delete_field

# Register field in _nmtlib:
_nmtlib.field_swigregister(field)


def field_free(fl):
    return _nmtlib.field_free(fl)

def field_alloc_sph(cs, mask, spin, maps, ntemp, temp, beam, pure_e, pure_b, n_iter_mask_purify, tol_pinv, niter, masked_input, is_lite, mask_only):
    return _nmtlib.field_alloc_sph(cs, mask, spin, maps, ntemp, temp, beam, pure_e, pure_b, n_iter_mask_purify, tol_pinv, niter, masked_input, is_lite, mask_only)

def field_read(is_healpix, fname_mask, fname_maps, fname_temp, fname_beam, spin, pure_e, pure_b, n_iter_mask_purify, tol_pinv, niter):
    return _nmtlib.field_read(is_healpix, fname_mask, fname_maps, fname_temp, fname_beam, spin, pure_e, pure_b, n_iter_mask_purify, tol_pinv, niter)

def synfast_sph(cs, nfields, spin_arr, lmax, cells, beam_fields, seed):
    return _nmtlib.synfast_sph(cs, nfields, spin_arr, lmax, cells, beam_fields, seed)

def purify(fl, mask, walm0, maps_in, maps_out, alms, niter):
    return _nmtlib.purify(fl, mask, walm0, maps_in, maps_out, alms, niter)

def apodize_mask(nside, mask_in, mask_out, aposize, apotype):
    return _nmtlib.apodize_mask(nside, mask_in, mask_out, aposize, apotype)

def apodize_mask_flat(nx, ny, lx, ly, mask_in, mask_out, aposize, apotype):
    return _nmtlib.apodize_mask_flat(nx, ny, lx, ly, mask_in, mask_out, aposize, apotype)
class workspace_flat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ncls = property(_nmtlib.workspace_flat_ncls_get, _nmtlib.workspace_flat_ncls_set)
    ellcut_x = property(_nmtlib.workspace_flat_ellcut_x_get, _nmtlib.workspace_flat_ellcut_x_set)
    ellcut_y = property(_nmtlib.workspace_flat_ellcut_y_get, _nmtlib.workspace_flat_ellcut_y_set)
    pe1 = property(_nmtlib.workspace_flat_pe1_get, _nmtlib.workspace_flat_pe1_set)
    pe2 = property(_nmtlib.workspace_flat_pe2_get, _nmtlib.workspace_flat_pe2_set)
    pb1 = property(_nmtlib.workspace_flat_pb1_get, _nmtlib.workspace_flat_pb1_set)
    pb2 = property(_nmtlib.workspace_flat_pb2_get, _nmtlib.workspace_flat_pb2_set)
    fs = property(_nmtlib.workspace_flat_fs_get, _nmtlib.workspace_flat_fs_set)
    is_teb = property(_nmtlib.workspace_flat_is_teb_get, _nmtlib.workspace_flat_is_teb_set)
    n_cells = property(_nmtlib.workspace_flat_n_cells_get, _nmtlib.workspace_flat_n_cells_set)
    coupling_matrix_unbinned = property(_nmtlib.workspace_flat_coupling_matrix_unbinned_get, _nmtlib.workspace_flat_coupling_matrix_unbinned_set)
    coupling_matrix_binned = property(_nmtlib.workspace_flat_coupling_matrix_binned_get, _nmtlib.workspace_flat_coupling_matrix_binned_set)
    bin = property(_nmtlib.workspace_flat_bin_get, _nmtlib.workspace_flat_bin_set)
    lmax = property(_nmtlib.workspace_flat_lmax_get, _nmtlib.workspace_flat_lmax_set)
    coupling_matrix_binned_gsl = property(_nmtlib.workspace_flat_coupling_matrix_binned_gsl_get, _nmtlib.workspace_flat_coupling_matrix_binned_gsl_set)
    coupling_matrix_perm = property(_nmtlib.workspace_flat_coupling_matrix_perm_get, _nmtlib.workspace_flat_coupling_matrix_perm_set)

    def __init__(self):
        _nmtlib.workspace_flat_swiginit(self, _nmtlib.new_workspace_flat())
    __swig_destroy__ = _nmtlib.delete_workspace_flat

# Register workspace_flat in _nmtlib:
_nmtlib.workspace_flat_swigregister(workspace_flat)


def workspace_flat_free(w):
    return _nmtlib.workspace_flat_free(w)

def compute_coupling_matrix_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, is_teb):
    return _nmtlib.compute_coupling_matrix_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, is_teb)

def compute_deprojection_bias_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, nl_prop, l_prop, cl_proposal, cl_bias):
    return _nmtlib.compute_deprojection_bias_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, nl_prop, l_prop, cl_proposal, cl_bias)

def couple_cl_l_flat_fast(w, nl, larr, cl_in, cl_out):
    return _nmtlib.couple_cl_l_flat_fast(w, nl, larr, cl_in, cl_out)

def couple_cl_l_flat_quick(w, nl, larr, cl_in, cl_out):
    return _nmtlib.couple_cl_l_flat_quick(w, nl, larr, cl_in, cl_out)

def decouple_cl_l_flat(w, cl_in, cl_noise_in, cl_bias, cl_out):
    return _nmtlib.decouple_cl_l_flat(w, cl_in, cl_noise_in, cl_bias, cl_out)

def compute_coupled_cell_flat(fl1, fl2, bin, cl_out, lmn_x, lmx_x, lmn_y, lmx_y):
    return _nmtlib.compute_coupled_cell_flat(fl1, fl2, bin, cl_out, lmn_x, lmx_x, lmn_y, lmx_y)

def compute_power_spectra_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, w0, cl_noise, nl_prop, l_prop, cl_prop, cl_out):
    return _nmtlib.compute_power_spectra_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, w0, cl_noise, nl_prop, l_prop, cl_prop, cl_out)
class workspace(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lmax = property(_nmtlib.workspace_lmax_get, _nmtlib.workspace_lmax_set)
    lmax_fields = property(_nmtlib.workspace_lmax_fields_get, _nmtlib.workspace_lmax_fields_set)
    lmax_mask = property(_nmtlib.workspace_lmax_mask_get, _nmtlib.workspace_lmax_mask_set)
    is_teb = property(_nmtlib.workspace_is_teb_get, _nmtlib.workspace_is_teb_set)
    ncls = property(_nmtlib.workspace_ncls_get, _nmtlib.workspace_ncls_set)
    cs = property(_nmtlib.workspace_cs_get, _nmtlib.workspace_cs_set)
    beam_prod = property(_nmtlib.workspace_beam_prod_get, _nmtlib.workspace_beam_prod_set)
    pcl_masks = property(_nmtlib.workspace_pcl_masks_get, _nmtlib.workspace_pcl_masks_set)
    coupling_matrix_unbinned = property(_nmtlib.workspace_coupling_matrix_unbinned_get, _nmtlib.workspace_coupling_matrix_unbinned_set)
    bin = property(_nmtlib.workspace_bin_get, _nmtlib.workspace_bin_set)
    coupling_matrix_binned = property(_nmtlib.workspace_coupling_matrix_binned_get, _nmtlib.workspace_coupling_matrix_binned_set)
    coupling_matrix_perm = property(_nmtlib.workspace_coupling_matrix_perm_get, _nmtlib.workspace_coupling_matrix_perm_set)

    def __init__(self):
        _nmtlib.workspace_swiginit(self, _nmtlib.new_workspace())
    __swig_destroy__ = _nmtlib.delete_workspace

# Register workspace in _nmtlib:
_nmtlib.workspace_swigregister(workspace)

class master_calculator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lmax = property(_nmtlib.master_calculator_lmax_get, _nmtlib.master_calculator_lmax_set)
    lmax_mask = property(_nmtlib.master_calculator_lmax_mask_get, _nmtlib.master_calculator_lmax_mask_set)
    npcl = property(_nmtlib.master_calculator_npcl_get, _nmtlib.master_calculator_npcl_set)
    s1 = property(_nmtlib.master_calculator_s1_get, _nmtlib.master_calculator_s1_set)
    s2 = property(_nmtlib.master_calculator_s2_get, _nmtlib.master_calculator_s2_set)
    has_00 = property(_nmtlib.master_calculator_has_00_get, _nmtlib.master_calculator_has_00_set)
    xi_00 = property(_nmtlib.master_calculator_xi_00_get, _nmtlib.master_calculator_xi_00_set)
    has_0s = property(_nmtlib.master_calculator_has_0s_get, _nmtlib.master_calculator_has_0s_set)
    xi_0s = property(_nmtlib.master_calculator_xi_0s_get, _nmtlib.master_calculator_xi_0s_set)
    has_ss = property(_nmtlib.master_calculator_has_ss_get, _nmtlib.master_calculator_has_ss_set)
    xi_pp = property(_nmtlib.master_calculator_xi_pp_get, _nmtlib.master_calculator_xi_pp_set)
    xi_mm = property(_nmtlib.master_calculator_xi_mm_get, _nmtlib.master_calculator_xi_mm_set)
    pure_e1 = property(_nmtlib.master_calculator_pure_e1_get, _nmtlib.master_calculator_pure_e1_set)
    pure_e2 = property(_nmtlib.master_calculator_pure_e2_get, _nmtlib.master_calculator_pure_e2_set)
    pure_b1 = property(_nmtlib.master_calculator_pure_b1_get, _nmtlib.master_calculator_pure_b1_set)
    pure_b2 = property(_nmtlib.master_calculator_pure_b2_get, _nmtlib.master_calculator_pure_b2_set)
    pure_any = property(_nmtlib.master_calculator_pure_any_get, _nmtlib.master_calculator_pure_any_set)
    npure_0s = property(_nmtlib.master_calculator_npure_0s_get, _nmtlib.master_calculator_npure_0s_set)
    npure_ss = property(_nmtlib.master_calculator_npure_ss_get, _nmtlib.master_calculator_npure_ss_set)

    def __init__(self):
        _nmtlib.master_calculator_swiginit(self, _nmtlib.new_master_calculator())
    __swig_destroy__ = _nmtlib.delete_master_calculator

# Register master_calculator in _nmtlib:
_nmtlib.master_calculator_swigregister(master_calculator)


def compute_master_coefficients(lmax, lmax_mask, npcl, pcl_masks, s1, s2, pure_e1, pure_b1, pure_e2, pure_b2, do_teb, l_toeplitz, l_exact, dl_band):
    return _nmtlib.compute_master_coefficients(lmax, lmax_mask, npcl, pcl_masks, s1, s2, pure_e1, pure_b1, pure_e2, pure_b2, do_teb, l_toeplitz, l_exact, dl_band)

def master_calculator_free(c):
    return _nmtlib.master_calculator_free(c)

def compute_coupling_matrix(fl1, fl2, bin, is_teb, niter, lmax_mask, l_toeplitz, l_exact, dl_band):
    return _nmtlib.compute_coupling_matrix(fl1, fl2, bin, is_teb, niter, lmax_mask, l_toeplitz, l_exact, dl_band)

def update_coupling_matrix(w, n_rows, new_matrix):
    return _nmtlib.update_coupling_matrix(w, n_rows, new_matrix)

def workspace_update_binning(w, bin):
    return _nmtlib.workspace_update_binning(w, bin)

def workspace_update_beams(w, nl1, b1, nl2, b2):
    return _nmtlib.workspace_update_beams(w, nl1, b1, nl2, b2)

def workspace_free(w):
    return _nmtlib.workspace_free(w)

def compute_deprojection_bias(fl1, fl2, cl_proposal, cl_bias, niter):
    return _nmtlib.compute_deprojection_bias(fl1, fl2, cl_proposal, cl_bias, niter)

def compute_uncorr_noise_deprojection_bias(fl1, map_var, cl_bias, niter):
    return _nmtlib.compute_uncorr_noise_deprojection_bias(fl1, map_var, cl_bias, niter)

def couple_cl_l(w, cl_in, cl_out):
    return _nmtlib.couple_cl_l(w, cl_in, cl_out)

def decouple_cl_l(w, cl_in, cl_noise_in, cl_bias, cl_out):
    return _nmtlib.decouple_cl_l(w, cl_in, cl_noise_in, cl_bias, cl_out)

def compute_bandpower_windows(w, bpw_win_out):
    return _nmtlib.compute_bandpower_windows(w, bpw_win_out)

def compute_coupled_cell(fl1, fl2, cl_out):
    return _nmtlib.compute_coupled_cell(fl1, fl2, cl_out)

def compute_power_spectra(fl1, fl2, bin, w0, cl_noise, cl_proposal, cl_out, niter, lmax_mask, l_toeplitz, l_exact, dl_band):
    return _nmtlib.compute_power_spectra(fl1, fl2, bin, w0, cl_noise, cl_proposal, cl_out, niter, lmax_mask, l_toeplitz, l_exact, dl_band)
class covar_workspace_flat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    bin = property(_nmtlib.covar_workspace_flat_bin_get, _nmtlib.covar_workspace_flat_bin_set)
    xi00_1122 = property(_nmtlib.covar_workspace_flat_xi00_1122_get, _nmtlib.covar_workspace_flat_xi00_1122_set)
    xi00_1221 = property(_nmtlib.covar_workspace_flat_xi00_1221_get, _nmtlib.covar_workspace_flat_xi00_1221_set)
    xi02_1122 = property(_nmtlib.covar_workspace_flat_xi02_1122_get, _nmtlib.covar_workspace_flat_xi02_1122_set)
    xi02_1221 = property(_nmtlib.covar_workspace_flat_xi02_1221_get, _nmtlib.covar_workspace_flat_xi02_1221_set)
    xi22p_1122 = property(_nmtlib.covar_workspace_flat_xi22p_1122_get, _nmtlib.covar_workspace_flat_xi22p_1122_set)
    xi22p_1221 = property(_nmtlib.covar_workspace_flat_xi22p_1221_get, _nmtlib.covar_workspace_flat_xi22p_1221_set)
    xi22m_1122 = property(_nmtlib.covar_workspace_flat_xi22m_1122_get, _nmtlib.covar_workspace_flat_xi22m_1122_set)
    xi22m_1221 = property(_nmtlib.covar_workspace_flat_xi22m_1221_get, _nmtlib.covar_workspace_flat_xi22m_1221_set)

    def __init__(self):
        _nmtlib.covar_workspace_flat_swiginit(self, _nmtlib.new_covar_workspace_flat())
    __swig_destroy__ = _nmtlib.delete_covar_workspace_flat

# Register covar_workspace_flat in _nmtlib:
_nmtlib.covar_workspace_flat_swigregister(covar_workspace_flat)


def covar_workspace_flat_free(cw):
    return _nmtlib.covar_workspace_flat_free(cw)

def covar_workspace_flat_init(fla1, fla2, ba, flb1, flb2, bb):
    return _nmtlib.covar_workspace_flat_init(fla1, fla2, ba, flb1, flb2, bb)

def compute_gaussian_covariance_flat(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, nl, larr, clac, clad, clbc, clbd, covar_out):
    return _nmtlib.compute_gaussian_covariance_flat(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, nl, larr, clac, clad, clbc, clbd, covar_out)
class covar_workspace(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lmax = property(_nmtlib.covar_workspace_lmax_get, _nmtlib.covar_workspace_lmax_set)
    spin0_only = property(_nmtlib.covar_workspace_spin0_only_get, _nmtlib.covar_workspace_spin0_only_set)
    xi00_1122 = property(_nmtlib.covar_workspace_xi00_1122_get, _nmtlib.covar_workspace_xi00_1122_set)
    xi00_1221 = property(_nmtlib.covar_workspace_xi00_1221_get, _nmtlib.covar_workspace_xi00_1221_set)
    xi02_1122 = property(_nmtlib.covar_workspace_xi02_1122_get, _nmtlib.covar_workspace_xi02_1122_set)
    xi02_1221 = property(_nmtlib.covar_workspace_xi02_1221_get, _nmtlib.covar_workspace_xi02_1221_set)
    xi22p_1122 = property(_nmtlib.covar_workspace_xi22p_1122_get, _nmtlib.covar_workspace_xi22p_1122_set)
    xi22p_1221 = property(_nmtlib.covar_workspace_xi22p_1221_get, _nmtlib.covar_workspace_xi22p_1221_set)
    xi22m_1122 = property(_nmtlib.covar_workspace_xi22m_1122_get, _nmtlib.covar_workspace_xi22m_1122_set)
    xi22m_1221 = property(_nmtlib.covar_workspace_xi22m_1221_get, _nmtlib.covar_workspace_xi22m_1221_set)

    def __init__(self):
        _nmtlib.covar_workspace_swiginit(self, _nmtlib.new_covar_workspace())
    __swig_destroy__ = _nmtlib.delete_covar_workspace

# Register covar_workspace in _nmtlib:
_nmtlib.covar_workspace_swigregister(covar_workspace)


def covar_workspace_free(cw):
    return _nmtlib.covar_workspace_free(cw)

def covar_workspace_init(fla1, fla2, flb1, flb2, lmax, niter, l_toeplitz, l_exact, dl_band, spin0_only):
    return _nmtlib.covar_workspace_init(fla1, fla2, flb1, flb2, lmax, niter, l_toeplitz, l_exact, dl_band, spin0_only)

def compute_gaussian_covariance(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, clac, clad, clbc, clbd, covar_out):
    return _nmtlib.compute_gaussian_covariance(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, clac, clad, clbc, clbd, covar_out)

def compute_gaussian_covariance_coupled(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, clac, clad, clbc, clbd, covar_out):
    return _nmtlib.compute_gaussian_covariance_coupled(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, clac, clad, clbc, clbd, covar_out)

def workspace_write_fits(w, fname):
    return _nmtlib.workspace_write_fits(w, fname)

def workspace_read_fits(fname, w_unbinned):
    return _nmtlib.workspace_read_fits(fname, w_unbinned)

def workspace_flat_read_fits(fname):
    return _nmtlib.workspace_flat_read_fits(fname)

def workspace_flat_write_fits(w, fname):
    return _nmtlib.workspace_flat_write_fits(w, fname)

def covar_workspace_write_fits(cw, fname):
    return _nmtlib.covar_workspace_write_fits(cw, fname)

def covar_workspace_read_fits(fname, force_spin0):
    return _nmtlib.covar_workspace_read_fits(fname, force_spin0)

def covar_workspace_flat_write_fits(cw, fname):
    return _nmtlib.covar_workspace_flat_write_fits(cw, fname)

def covar_workspace_flat_read_fits(fname):
    return _nmtlib.covar_workspace_flat_read_fits(fname)

def get_nell_list(bins, iout):
    return _nmtlib.get_nell_list(bins, iout)

def get_nell(bins, ibin):
    return _nmtlib.get_nell(bins, ibin)

def get_ell_list(bins, ibin, iout):
    return _nmtlib.get_ell_list(bins, ibin, iout)

def get_weight_list(bins, ibin, dout):
    return _nmtlib.get_weight_list(bins, ibin, dout)

def get_lmax_py(is_healpix, nside, nx, ny, delta_phi, delta_theta, phi0, theta0):
    return _nmtlib.get_lmax_py(is_healpix, nside, nx, ny, delta_phi, delta_theta, phi0, theta0)

def get_lmax_from_cs_py(cs):
    return _nmtlib.get_lmax_from_cs_py(cs)

def get_ell_eff(bins, dout):
    return _nmtlib.get_ell_eff(bins, dout)

def get_ell_eff_flat(bins, dout):
    return _nmtlib.get_ell_eff_flat(bins, dout)

def bins_create_py(nell1, nell2, nell3, nell4, lmax):
    return _nmtlib.bins_create_py(nell1, nell2, nell3, nell4, lmax)

def update_mcm(w, n_rows, nell3):
    return _nmtlib.update_mcm(w, n_rows, nell3)

def get_bandpower_windows(w, dout):
    return _nmtlib.get_bandpower_windows(w, dout)

def get_mcm(w, ldout):
    return _nmtlib.get_mcm(w, ldout)

def bins_flat_create_py(npix_1, nell3):
    return _nmtlib.bins_flat_create_py(npix_1, nell3)

def bin_cl(bins, ncl1, dout):
    return _nmtlib.bin_cl(bins, ncl1, dout)

def bin_cl_flat(bins, nell3, ncl1, dout):
    return _nmtlib.bin_cl_flat(bins, nell3, ncl1, dout)

def unbin_cl(bins, ncl1, dout):
    return _nmtlib.unbin_cl(bins, ncl1, dout)

def unbin_cl_flat(bins, ncl1, nell3, dout):
    return _nmtlib.unbin_cl_flat(bins, ncl1, nell3, dout)

def field_alloc_empty(is_healpix, nside, lmax_sht, nx, ny, delta_phi, delta_theta, phi0, theta0, spin, npix_1, nell3, pure_e, pure_b, n_iter_mask_purify):
    return _nmtlib.field_alloc_empty(is_healpix, nside, lmax_sht, nx, ny, delta_phi, delta_theta, phi0, theta0, spin, npix_1, nell3, pure_e, pure_b, n_iter_mask_purify)

def field_alloc_new(is_healpix, nside, lmax_sht, nx, ny, delta_phi, delta_theta, phi0, theta0, spin, npix_1, nmap_2, ntmp_3, nell3, pure_e, pure_b, n_iter_mask_purify, tol_pinv, n_iter, masked_input, lite):
    return _nmtlib.field_alloc_new(is_healpix, nside, lmax_sht, nx, ny, delta_phi, delta_theta, phi0, theta0, spin, npix_1, nmap_2, ntmp_3, nell3, pure_e, pure_b, n_iter_mask_purify, tol_pinv, n_iter, masked_input, lite)

def field_alloc_new_notemp(is_healpix, nside, lmax_sht, nx, ny, delta_phi, delta_theta, phi0, theta0, spin, npix_1, nmap_2, nell3, pure_e, pure_b, n_iter_mask_purify, n_iter, masked_input, lite):
    return _nmtlib.field_alloc_new_notemp(is_healpix, nside, lmax_sht, nx, ny, delta_phi, delta_theta, phi0, theta0, spin, npix_1, nmap_2, nell3, pure_e, pure_b, n_iter_mask_purify, n_iter, masked_input, lite)

def field_alloc_empty_flat(nx, ny, lx, ly, spin, npix_1, ncl1, pure_e, pure_b):
    return _nmtlib.field_alloc_empty_flat(nx, ny, lx, ly, spin, npix_1, ncl1, pure_e, pure_b)

def field_alloc_new_flat(nx, ny, lx, ly, spin, npix_1, nmap_2, ntmp_3, ncl1, pure_e, pure_b, tol_pinv, masked_input, lite):
    return _nmtlib.field_alloc_new_flat(nx, ny, lx, ly, spin, npix_1, nmap_2, ntmp_3, ncl1, pure_e, pure_b, tol_pinv, masked_input, lite)

def field_alloc_new_notemp_flat(nx, ny, lx, ly, spin, npix_1, nmap_2, ncl1, pure_e, pure_b, masked_input, lite):
    return _nmtlib.field_alloc_new_notemp_flat(nx, ny, lx, ly, spin, npix_1, nmap_2, ncl1, pure_e, pure_b, masked_input, lite)

def get_mask(fl, ldout):
    return _nmtlib.get_mask(fl, ldout)

def get_map(fl, imap, ldout):
    return _nmtlib.get_map(fl, imap, ldout)

def get_alms(fl, imap, ldout):
    return _nmtlib.get_alms(fl, imap, ldout)

def get_mask_flat(fl, dout):
    return _nmtlib.get_mask_flat(fl, dout)

def get_map_flat(fl, imap, dout):
    return _nmtlib.get_map_flat(fl, imap, dout)

def get_temp(fl, itemp, imap, ldout):
    return _nmtlib.get_temp(fl, itemp, imap, ldout)

def get_temp_flat(fl, itemp, imap, dout):
    return _nmtlib.get_temp_flat(fl, itemp, imap, dout)

def apomask(npix_1, ldout, aposize, apotype):
    return _nmtlib.apomask(npix_1, ldout, aposize, apotype)

def apomask_flat(nx, ny, lx, ly, npix_1, dout, aposize, apotype):
    return _nmtlib.apomask_flat(nx, ny, lx, ly, npix_1, dout, aposize, apotype)

def synfast_new(is_healpix, nside, nx, ny, delta_phi, delta_theta, phi0, theta0, nfields, seed, ncl1, ncl2, ldout):
    return _nmtlib.synfast_new(is_healpix, nside, nx, ny, delta_phi, delta_theta, phi0, theta0, nfields, seed, ncl1, ncl2, ldout)

def synfast_new_flat(nx, ny, lx, ly, nfields, seed, ncl1, ncl2, dout):
    return _nmtlib.synfast_new_flat(nx, ny, lx, ly, nfields, seed, ncl1, ncl2, dout)

def comp_coupling_matrix(fl1, fl2, bin, is_teb, n_iter, lmax_mask, l_toeplitz, l_exact, dl_band):
    return _nmtlib.comp_coupling_matrix(fl1, fl2, bin, is_teb, n_iter, lmax_mask, l_toeplitz, l_exact, dl_band)

def comp_coupling_matrix_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, is_teb):
    return _nmtlib.comp_coupling_matrix_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, is_teb)

def read_workspace(fname, w_unbinned):
    return _nmtlib.read_workspace(fname, w_unbinned)

def write_workspace(w, fname):
    return _nmtlib.write_workspace(w, fname)

def read_workspace_flat(fname):
    return _nmtlib.read_workspace_flat(fname)

def write_workspace_flat(w, fname):
    return _nmtlib.write_workspace_flat(w, fname)

def comp_uncorr_noise_deproj_bias(fl1, npix_1, dout, n_iter):
    return _nmtlib.comp_uncorr_noise_deproj_bias(fl1, npix_1, dout, n_iter)

def comp_deproj_bias(fl1, fl2, ncl1, dout, n_iter):
    return _nmtlib.comp_deproj_bias(fl1, fl2, ncl1, dout, n_iter)

def comp_deproj_bias_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, nell3, ncl1, dout):
    return _nmtlib.comp_deproj_bias_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, nell3, ncl1, dout)

def write_covar_workspace(cw, fname):
    return _nmtlib.write_covar_workspace(cw, fname)

def read_covar_workspace(fname, force_spin0):
    return _nmtlib.read_covar_workspace(fname, force_spin0)

def covar_workspace_init_py(fa1, fa2, fb1, fb2, lmax, n_iter, l_toeplitz, l_exact, dl_band, spin0_only):
    return _nmtlib.covar_workspace_init_py(fa1, fa2, fb1, fb2, lmax, n_iter, l_toeplitz, l_exact, dl_band, spin0_only)

def write_covar_workspace_flat(cw, fname):
    return _nmtlib.write_covar_workspace_flat(cw, fname)

def read_covar_workspace_flat(fname):
    return _nmtlib.read_covar_workspace_flat(fname)

def covar_workspace_flat_init_py(fa1, fa2, ba, fb1, fb2, bb):
    return _nmtlib.covar_workspace_flat_init_py(fa1, fa2, ba, fb1, fb2, bb)

def comp_gaussian_covariance(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, ncl11, ncl12, ncl21, ncl22, dout):
    return _nmtlib.comp_gaussian_covariance(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, ncl11, ncl12, ncl21, ncl22, dout)

def comp_gaussian_covariance_coupled(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, ncl11, ncl12, ncl21, ncl22, dout):
    return _nmtlib.comp_gaussian_covariance_coupled(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, ncl11, ncl12, ncl21, ncl22, dout)

def comp_gaussian_covariance_flat(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, nell3, ncl11, ncl12, ncl21, ncl22, dout):
    return _nmtlib.comp_gaussian_covariance_flat(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, nell3, ncl11, ncl12, ncl21, ncl22, dout)

def comp_pspec_coupled(fl1, fl2, dout):
    return _nmtlib.comp_pspec_coupled(fl1, fl2, dout)

def comp_pspec_coupled_flat(fl1, fl2, bin, dout, lmn_x, lmx_x, lmn_y, lmx_y):
    return _nmtlib.comp_pspec_coupled_flat(fl1, fl2, bin, dout, lmn_x, lmx_x, lmn_y, lmx_y)

def decouple_cell_py(w, ncl1, ncl2, ncl3, dout):
    return _nmtlib.decouple_cell_py(w, ncl1, ncl2, ncl3, dout)

def decouple_cell_py_flat(w, ncl1, ncl2, ncl3, dout):
    return _nmtlib.decouple_cell_py_flat(w, ncl1, ncl2, ncl3, dout)

def couple_cell_py(w, ncl1, dout):
    return _nmtlib.couple_cell_py(w, ncl1, dout)

def couple_cell_py_flat(w, nell3, ncl1, dout):
    return _nmtlib.couple_cell_py_flat(w, nell3, ncl1, dout)

def comp_pspec(fl1, fl2, bin, w0, ncl1, ncl2, dout, n_iter, lmax_mask, l_toeplitz, l_exact, dl_band):
    return _nmtlib.comp_pspec(fl1, fl2, bin, w0, ncl1, ncl2, dout, n_iter, lmax_mask, l_toeplitz, l_exact, dl_band)

def wsp_update_beams(w, nell3, nell4):
    return _nmtlib.wsp_update_beams(w, nell3, nell4)

def wsp_update_bins(w, b):
    return _nmtlib.wsp_update_bins(w, b)

def comp_pspec_flat(fl1, fl2, bin, w0, ncl1, nell3, ncl2, dout, lmn_x, lmx_x, lmn_y, lmx_y):
    return _nmtlib.comp_pspec_flat(fl1, fl2, bin, w0, ncl1, nell3, ncl2, dout, lmn_x, lmx_x, lmn_y, lmx_y)


