# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    import _nmtlib
else:
    import _nmtlib

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class binning_scheme_flat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n_bands = property(_nmtlib.binning_scheme_flat_n_bands_get, _nmtlib.binning_scheme_flat_n_bands_set)
    ell_0_list = property(_nmtlib.binning_scheme_flat_ell_0_list_get, _nmtlib.binning_scheme_flat_ell_0_list_set)
    ell_f_list = property(_nmtlib.binning_scheme_flat_ell_f_list_get, _nmtlib.binning_scheme_flat_ell_f_list_set)

    def __init__(self):
        _nmtlib.binning_scheme_flat_swiginit(self, _nmtlib.new_binning_scheme_flat())
    __swig_destroy__ = _nmtlib.delete_binning_scheme_flat

# Register binning_scheme_flat in _nmtlib:
_nmtlib.binning_scheme_flat_swigregister(binning_scheme_flat)


def bins_flat_constant(nlb, lmax):
    return _nmtlib.bins_flat_constant(nlb, lmax)

def bins_flat_create(nell, l0, lf):
    return _nmtlib.bins_flat_create(nell, l0, lf)

def bins_flat_free(bin):
    return _nmtlib.bins_flat_free(bin)

def bin_cls_flat(bin, nl, larr, cls_in, cls_out, ncls):
    return _nmtlib.bin_cls_flat(bin, nl, larr, cls_in, cls_out, ncls)

def unbin_cls_flat(bin, cls_in, nl, larr, cls_out, ncls):
    return _nmtlib.unbin_cls_flat(bin, cls_in, nl, larr, cls_out, ncls)

def ell_eff_flat(bin, larr):
    return _nmtlib.ell_eff_flat(bin, larr)

def bins_flat_search_fast(bin, l, il):
    return _nmtlib.bins_flat_search_fast(bin, l, il)
class binning_scheme(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n_bands = property(_nmtlib.binning_scheme_n_bands_get, _nmtlib.binning_scheme_n_bands_set)
    nell_list = property(_nmtlib.binning_scheme_nell_list_get, _nmtlib.binning_scheme_nell_list_set)
    ell_list = property(_nmtlib.binning_scheme_ell_list_get, _nmtlib.binning_scheme_ell_list_set)
    w_list = property(_nmtlib.binning_scheme_w_list_get, _nmtlib.binning_scheme_w_list_set)
    f_ell = property(_nmtlib.binning_scheme_f_ell_get, _nmtlib.binning_scheme_f_ell_set)
    ell_max = property(_nmtlib.binning_scheme_ell_max_get, _nmtlib.binning_scheme_ell_max_set)

    def __init__(self):
        _nmtlib.binning_scheme_swiginit(self, _nmtlib.new_binning_scheme())
    __swig_destroy__ = _nmtlib.delete_binning_scheme

# Register binning_scheme in _nmtlib:
_nmtlib.binning_scheme_swigregister(binning_scheme)


def bins_constant(nlb, lmax, is_l2):
    return _nmtlib.bins_constant(nlb, lmax, is_l2)

def bins_create(nell, bpws, ells, weights, f_ell, lmax):
    return _nmtlib.bins_create(nell, bpws, ells, weights, f_ell, lmax)

def bins_free(bin):
    return _nmtlib.bins_free(bin)

def bin_cls(bin, cls_in, cls_out, ncls):
    return _nmtlib.bin_cls(bin, cls_in, cls_out, ncls)

def unbin_cls(bin, cls_in, cls_out, ncls):
    return _nmtlib.unbin_cls(bin, cls_in, cls_out, ncls)

def ell_eff(bin, larr):
    return _nmtlib.ell_eff(bin, larr)
class k_function(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_const = property(_nmtlib.k_function_is_const_get, _nmtlib.k_function_is_const_set)
    x0 = property(_nmtlib.k_function_x0_get, _nmtlib.k_function_x0_set)
    xf = property(_nmtlib.k_function_xf_get, _nmtlib.k_function_xf_set)
    y0 = property(_nmtlib.k_function_y0_get, _nmtlib.k_function_y0_set)
    yf = property(_nmtlib.k_function_yf_get, _nmtlib.k_function_yf_set)
    spl = property(_nmtlib.k_function_spl_get, _nmtlib.k_function_spl_set)

    def __init__(self):
        _nmtlib.k_function_swiginit(self, _nmtlib.new_k_function())
    __swig_destroy__ = _nmtlib.delete_k_function

# Register k_function in _nmtlib:
_nmtlib.k_function_swigregister(k_function)


def k_function_alloc(nk, karr, farr, y0, yf, is_const):
    return _nmtlib.k_function_alloc(nk, karr, farr, y0, yf, is_const)

def k_function_free(f):
    return _nmtlib.k_function_free(f)

def k_function_eval(f, k, intacc):
    return _nmtlib.k_function_eval(f, k, intacc)
class flatsky_info(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nx = property(_nmtlib.flatsky_info_nx_get, _nmtlib.flatsky_info_nx_set)
    ny = property(_nmtlib.flatsky_info_ny_get, _nmtlib.flatsky_info_ny_set)
    npix = property(_nmtlib.flatsky_info_npix_get, _nmtlib.flatsky_info_npix_set)
    lx = property(_nmtlib.flatsky_info_lx_get, _nmtlib.flatsky_info_lx_set)
    ly = property(_nmtlib.flatsky_info_ly_get, _nmtlib.flatsky_info_ly_set)
    pixsize = property(_nmtlib.flatsky_info_pixsize_get, _nmtlib.flatsky_info_pixsize_set)
    n_ell = property(_nmtlib.flatsky_info_n_ell_get, _nmtlib.flatsky_info_n_ell_set)
    dell = property(_nmtlib.flatsky_info_dell_get, _nmtlib.flatsky_info_dell_set)
    i_dell = property(_nmtlib.flatsky_info_i_dell_get, _nmtlib.flatsky_info_i_dell_set)
    ell_min = property(_nmtlib.flatsky_info_ell_min_get, _nmtlib.flatsky_info_ell_min_set)

    def __init__(self):
        _nmtlib.flatsky_info_swiginit(self, _nmtlib.new_flatsky_info())
    __swig_destroy__ = _nmtlib.delete_flatsky_info

# Register flatsky_info in _nmtlib:
_nmtlib.flatsky_info_swigregister(flatsky_info)


def flatsky_info_alloc(nx, ny, lx, ly):
    return _nmtlib.flatsky_info_alloc(nx, ny, lx, ly)

def flatsky_info_free(fs):
    return _nmtlib.flatsky_info_free(fs)
class field_flat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    fs = property(_nmtlib.field_flat_fs_get, _nmtlib.field_flat_fs_set)
    npix = property(_nmtlib.field_flat_npix_get, _nmtlib.field_flat_npix_set)
    pure_e = property(_nmtlib.field_flat_pure_e_get, _nmtlib.field_flat_pure_e_set)
    pure_b = property(_nmtlib.field_flat_pure_b_get, _nmtlib.field_flat_pure_b_set)
    mask = property(_nmtlib.field_flat_mask_get, _nmtlib.field_flat_mask_set)
    a_mask = property(_nmtlib.field_flat_a_mask_get, _nmtlib.field_flat_a_mask_set)
    spin = property(_nmtlib.field_flat_spin_get, _nmtlib.field_flat_spin_set)
    nmaps = property(_nmtlib.field_flat_nmaps_get, _nmtlib.field_flat_nmaps_set)
    maps = property(_nmtlib.field_flat_maps_get, _nmtlib.field_flat_maps_set)
    alms = property(_nmtlib.field_flat_alms_get, _nmtlib.field_flat_alms_set)
    ntemp = property(_nmtlib.field_flat_ntemp_get, _nmtlib.field_flat_ntemp_set)
    temp = property(_nmtlib.field_flat_temp_get, _nmtlib.field_flat_temp_set)
    a_temp = property(_nmtlib.field_flat_a_temp_get, _nmtlib.field_flat_a_temp_set)
    matrix_M = property(_nmtlib.field_flat_matrix_M_get, _nmtlib.field_flat_matrix_M_set)
    beam = property(_nmtlib.field_flat_beam_get, _nmtlib.field_flat_beam_set)
    lite = property(_nmtlib.field_flat_lite_get, _nmtlib.field_flat_lite_set)
    mask_only = property(_nmtlib.field_flat_mask_only_get, _nmtlib.field_flat_mask_only_set)

    def __init__(self):
        _nmtlib.field_flat_swiginit(self, _nmtlib.new_field_flat())
    __swig_destroy__ = _nmtlib.delete_field_flat

# Register field_flat in _nmtlib:
_nmtlib.field_flat_swigregister(field_flat)


def field_flat_free(fl):
    return _nmtlib.field_flat_free(fl)

def field_flat_alloc(nx, ny, lx, ly, mask, spin, maps, ntemp, temp, nl_beam, l_beam, beam, pure_e, pure_b, tol_pinv, masked_input, is_lite, mask_only):
    return _nmtlib.field_flat_alloc(nx, ny, lx, ly, mask, spin, maps, ntemp, temp, nl_beam, l_beam, beam, pure_e, pure_b, tol_pinv, masked_input, is_lite, mask_only)

def synfast_flat(nx, ny, lx, ly, nfields, spin_arr, nl_beam, l_beam, beam_fields, nl_cell, l_cell, cell_fields, seed):
    return _nmtlib.synfast_flat(nx, ny, lx, ly, nfields, spin_arr, nl_beam, l_beam, beam_fields, nl_cell, l_cell, cell_fields, seed)

def purify_flat(fl, mask, walm0, maps_in, maps_out, alms):
    return _nmtlib.purify_flat(fl, mask, walm0, maps_in, maps_out, alms)

def apodize_mask(nside, mask_in, mask_out, aposize, apotype):
    return _nmtlib.apodize_mask(nside, mask_in, mask_out, aposize, apotype)

def apodize_mask_flat(nx, ny, lx, ly, mask_in, mask_out, aposize, apotype):
    return _nmtlib.apodize_mask_flat(nx, ny, lx, ly, mask_in, mask_out, aposize, apotype)
class workspace_flat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ncls = property(_nmtlib.workspace_flat_ncls_get, _nmtlib.workspace_flat_ncls_set)
    ellcut_x = property(_nmtlib.workspace_flat_ellcut_x_get, _nmtlib.workspace_flat_ellcut_x_set)
    ellcut_y = property(_nmtlib.workspace_flat_ellcut_y_get, _nmtlib.workspace_flat_ellcut_y_set)
    pe1 = property(_nmtlib.workspace_flat_pe1_get, _nmtlib.workspace_flat_pe1_set)
    pe2 = property(_nmtlib.workspace_flat_pe2_get, _nmtlib.workspace_flat_pe2_set)
    pb1 = property(_nmtlib.workspace_flat_pb1_get, _nmtlib.workspace_flat_pb1_set)
    pb2 = property(_nmtlib.workspace_flat_pb2_get, _nmtlib.workspace_flat_pb2_set)
    fs = property(_nmtlib.workspace_flat_fs_get, _nmtlib.workspace_flat_fs_set)
    is_teb = property(_nmtlib.workspace_flat_is_teb_get, _nmtlib.workspace_flat_is_teb_set)
    n_cells = property(_nmtlib.workspace_flat_n_cells_get, _nmtlib.workspace_flat_n_cells_set)
    coupling_matrix_unbinned = property(_nmtlib.workspace_flat_coupling_matrix_unbinned_get, _nmtlib.workspace_flat_coupling_matrix_unbinned_set)
    coupling_matrix_binned = property(_nmtlib.workspace_flat_coupling_matrix_binned_get, _nmtlib.workspace_flat_coupling_matrix_binned_set)
    bin = property(_nmtlib.workspace_flat_bin_get, _nmtlib.workspace_flat_bin_set)
    lmax = property(_nmtlib.workspace_flat_lmax_get, _nmtlib.workspace_flat_lmax_set)
    coupling_matrix_binned_gsl = property(_nmtlib.workspace_flat_coupling_matrix_binned_gsl_get, _nmtlib.workspace_flat_coupling_matrix_binned_gsl_set)
    coupling_matrix_perm = property(_nmtlib.workspace_flat_coupling_matrix_perm_get, _nmtlib.workspace_flat_coupling_matrix_perm_set)

    def __init__(self):
        _nmtlib.workspace_flat_swiginit(self, _nmtlib.new_workspace_flat())
    __swig_destroy__ = _nmtlib.delete_workspace_flat

# Register workspace_flat in _nmtlib:
_nmtlib.workspace_flat_swigregister(workspace_flat)


def workspace_flat_free(w):
    return _nmtlib.workspace_flat_free(w)

def compute_coupling_matrix_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, is_teb):
    return _nmtlib.compute_coupling_matrix_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, is_teb)

def compute_deprojection_bias_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, nl_prop, l_prop, cl_proposal, cl_bias):
    return _nmtlib.compute_deprojection_bias_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, nl_prop, l_prop, cl_proposal, cl_bias)

def couple_cl_l_flat_fast(w, nl, larr, cl_in, cl_out):
    return _nmtlib.couple_cl_l_flat_fast(w, nl, larr, cl_in, cl_out)

def couple_cl_l_flat_quick(w, nl, larr, cl_in, cl_out):
    return _nmtlib.couple_cl_l_flat_quick(w, nl, larr, cl_in, cl_out)

def decouple_cl_l_flat(w, cl_in, cl_noise_in, cl_bias, cl_out):
    return _nmtlib.decouple_cl_l_flat(w, cl_in, cl_noise_in, cl_bias, cl_out)

def compute_coupled_cell_flat(fl1, fl2, bin, cl_out, lmn_x, lmx_x, lmn_y, lmx_y):
    return _nmtlib.compute_coupled_cell_flat(fl1, fl2, bin, cl_out, lmn_x, lmx_x, lmn_y, lmx_y)

def compute_power_spectra_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, w0, cl_noise, nl_prop, l_prop, cl_prop, cl_out):
    return _nmtlib.compute_power_spectra_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, w0, cl_noise, nl_prop, l_prop, cl_prop, cl_out)
class workspace(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lmax = property(_nmtlib.workspace_lmax_get, _nmtlib.workspace_lmax_set)
    lmax_fields = property(_nmtlib.workspace_lmax_fields_get, _nmtlib.workspace_lmax_fields_set)
    lmax_mask = property(_nmtlib.workspace_lmax_mask_get, _nmtlib.workspace_lmax_mask_set)
    is_teb = property(_nmtlib.workspace_is_teb_get, _nmtlib.workspace_is_teb_set)
    ncls = property(_nmtlib.workspace_ncls_get, _nmtlib.workspace_ncls_set)
    beam_prod = property(_nmtlib.workspace_beam_prod_get, _nmtlib.workspace_beam_prod_set)
    pcl_masks = property(_nmtlib.workspace_pcl_masks_get, _nmtlib.workspace_pcl_masks_set)
    coupling_matrix_unbinned = property(_nmtlib.workspace_coupling_matrix_unbinned_get, _nmtlib.workspace_coupling_matrix_unbinned_set)
    bin = property(_nmtlib.workspace_bin_get, _nmtlib.workspace_bin_set)
    norm_type = property(_nmtlib.workspace_norm_type_get, _nmtlib.workspace_norm_type_set)
    w2 = property(_nmtlib.workspace_w2_get, _nmtlib.workspace_w2_set)
    coupling_matrix_binned = property(_nmtlib.workspace_coupling_matrix_binned_get, _nmtlib.workspace_coupling_matrix_binned_set)
    coupling_matrix_perm = property(_nmtlib.workspace_coupling_matrix_perm_get, _nmtlib.workspace_coupling_matrix_perm_set)

    def __init__(self):
        _nmtlib.workspace_swiginit(self, _nmtlib.new_workspace())
    __swig_destroy__ = _nmtlib.delete_workspace

# Register workspace in _nmtlib:
_nmtlib.workspace_swigregister(workspace)

class master_calculator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lmax = property(_nmtlib.master_calculator_lmax_get, _nmtlib.master_calculator_lmax_set)
    lmax_mask = property(_nmtlib.master_calculator_lmax_mask_get, _nmtlib.master_calculator_lmax_mask_set)
    npcl = property(_nmtlib.master_calculator_npcl_get, _nmtlib.master_calculator_npcl_set)
    s1 = property(_nmtlib.master_calculator_s1_get, _nmtlib.master_calculator_s1_set)
    s2 = property(_nmtlib.master_calculator_s2_get, _nmtlib.master_calculator_s2_set)
    has_00 = property(_nmtlib.master_calculator_has_00_get, _nmtlib.master_calculator_has_00_set)
    xi_00 = property(_nmtlib.master_calculator_xi_00_get, _nmtlib.master_calculator_xi_00_set)
    has_0s = property(_nmtlib.master_calculator_has_0s_get, _nmtlib.master_calculator_has_0s_set)
    xi_0s = property(_nmtlib.master_calculator_xi_0s_get, _nmtlib.master_calculator_xi_0s_set)
    has_ss = property(_nmtlib.master_calculator_has_ss_get, _nmtlib.master_calculator_has_ss_set)
    xi_pp = property(_nmtlib.master_calculator_xi_pp_get, _nmtlib.master_calculator_xi_pp_set)
    xi_mm = property(_nmtlib.master_calculator_xi_mm_get, _nmtlib.master_calculator_xi_mm_set)
    lfac = property(_nmtlib.master_calculator_lfac_get, _nmtlib.master_calculator_lfac_set)
    pure_e1 = property(_nmtlib.master_calculator_pure_e1_get, _nmtlib.master_calculator_pure_e1_set)
    pure_e2 = property(_nmtlib.master_calculator_pure_e2_get, _nmtlib.master_calculator_pure_e2_set)
    pure_b1 = property(_nmtlib.master_calculator_pure_b1_get, _nmtlib.master_calculator_pure_b1_set)
    pure_b2 = property(_nmtlib.master_calculator_pure_b2_get, _nmtlib.master_calculator_pure_b2_set)
    pure_any = property(_nmtlib.master_calculator_pure_any_get, _nmtlib.master_calculator_pure_any_set)
    npure_0s = property(_nmtlib.master_calculator_npure_0s_get, _nmtlib.master_calculator_npure_0s_set)
    npure_ss = property(_nmtlib.master_calculator_npure_ss_get, _nmtlib.master_calculator_npure_ss_set)

    def __init__(self):
        _nmtlib.master_calculator_swiginit(self, _nmtlib.new_master_calculator())
    __swig_destroy__ = _nmtlib.delete_master_calculator

# Register master_calculator in _nmtlib:
_nmtlib.master_calculator_swigregister(master_calculator)


def compute_master_coefficients(lmax, lmax_mask, npcl, pcl_masks, s1, s2, pure_e1, pure_b1, pure_e2, pure_b2, do_teb, l_toeplitz, l_exact, dl_band):
    return _nmtlib.compute_master_coefficients(lmax, lmax_mask, npcl, pcl_masks, s1, s2, pure_e1, pure_b1, pure_e2, pure_b2, do_teb, l_toeplitz, l_exact, dl_band)

def master_calculator_free(c):
    return _nmtlib.master_calculator_free(c)

def compute_coupling_matrix_anisotropic(spin1, spin2, mask_aniso_1, mask_aniso_2, lmax, lmax_mask, pcl_masks_00, pcl_masks_0e, pcl_masks_e0, pcl_masks_0b, pcl_masks_b0, pcl_masks_ee, pcl_masks_eb, pcl_masks_be, pcl_masks_bb, beam1, beam2, bin, norm_type, w2):
    return _nmtlib.compute_coupling_matrix_anisotropic(spin1, spin2, mask_aniso_1, mask_aniso_2, lmax, lmax_mask, pcl_masks_00, pcl_masks_0e, pcl_masks_e0, pcl_masks_0b, pcl_masks_b0, pcl_masks_ee, pcl_masks_eb, pcl_masks_be, pcl_masks_bb, beam1, beam2, bin, norm_type, w2)

def compute_general_coupling_matrix(lmax, pcl_mask, s1, s2, n1, n2, xi_out):
    return _nmtlib.compute_general_coupling_matrix(lmax, pcl_mask, s1, s2, n1, n2, xi_out)

def compute_coupling_matrix(spin1, spin2, lmax, lmax_mask, pure_e1, pure_b1, pure_e2, pure_b2, pcl_masks, beam1, beam2, bin, is_teb, l_toeplitz, l_exact, dl_band, norm_type, w2):
    return _nmtlib.compute_coupling_matrix(spin1, spin2, lmax, lmax_mask, pure_e1, pure_b1, pure_e2, pure_b2, pcl_masks, beam1, beam2, bin, is_teb, l_toeplitz, l_exact, dl_band, norm_type, w2)

def update_coupling_matrix(w, n_rows, new_matrix):
    return _nmtlib.update_coupling_matrix(w, n_rows, new_matrix)

def workspace_update_binning(w, bin):
    return _nmtlib.workspace_update_binning(w, bin)

def workspace_update_beams(w, nl1, b1, nl2, b2):
    return _nmtlib.workspace_update_beams(w, nl1, b1, nl2, b2)

def workspace_free(w):
    return _nmtlib.workspace_free(w)

def couple_cl_l(w, cl_in, cl_out):
    return _nmtlib.couple_cl_l(w, cl_in, cl_out)

def decouple_cl_l(w, cl_in, cl_noise_in, cl_bias, cl_out):
    return _nmtlib.decouple_cl_l(w, cl_in, cl_noise_in, cl_bias, cl_out)

def compute_bandpower_windows(w, bpw_win_out):
    return _nmtlib.compute_bandpower_windows(w, bpw_win_out)
class covar_workspace_flat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    bin = property(_nmtlib.covar_workspace_flat_bin_get, _nmtlib.covar_workspace_flat_bin_set)
    xi00_1122 = property(_nmtlib.covar_workspace_flat_xi00_1122_get, _nmtlib.covar_workspace_flat_xi00_1122_set)
    xi00_1221 = property(_nmtlib.covar_workspace_flat_xi00_1221_get, _nmtlib.covar_workspace_flat_xi00_1221_set)
    xi02_1122 = property(_nmtlib.covar_workspace_flat_xi02_1122_get, _nmtlib.covar_workspace_flat_xi02_1122_set)
    xi02_1221 = property(_nmtlib.covar_workspace_flat_xi02_1221_get, _nmtlib.covar_workspace_flat_xi02_1221_set)
    xi22p_1122 = property(_nmtlib.covar_workspace_flat_xi22p_1122_get, _nmtlib.covar_workspace_flat_xi22p_1122_set)
    xi22p_1221 = property(_nmtlib.covar_workspace_flat_xi22p_1221_get, _nmtlib.covar_workspace_flat_xi22p_1221_set)
    xi22m_1122 = property(_nmtlib.covar_workspace_flat_xi22m_1122_get, _nmtlib.covar_workspace_flat_xi22m_1122_set)
    xi22m_1221 = property(_nmtlib.covar_workspace_flat_xi22m_1221_get, _nmtlib.covar_workspace_flat_xi22m_1221_set)

    def __init__(self):
        _nmtlib.covar_workspace_flat_swiginit(self, _nmtlib.new_covar_workspace_flat())
    __swig_destroy__ = _nmtlib.delete_covar_workspace_flat

# Register covar_workspace_flat in _nmtlib:
_nmtlib.covar_workspace_flat_swigregister(covar_workspace_flat)


def covar_workspace_flat_free(cw):
    return _nmtlib.covar_workspace_flat_free(cw)

def covar_workspace_flat_init(fla1, fla2, ba, flb1, flb2, bb):
    return _nmtlib.covar_workspace_flat_init(fla1, fla2, ba, flb1, flb2, bb)

def compute_gaussian_covariance_flat(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, nl, larr, clac, clad, clbc, clbd, covar_out):
    return _nmtlib.compute_gaussian_covariance_flat(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, nl, larr, clac, clad, clbc, clbd, covar_out)
class covar_workspace(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lmax = property(_nmtlib.covar_workspace_lmax_get, _nmtlib.covar_workspace_lmax_set)
    lmax_mask = property(_nmtlib.covar_workspace_lmax_mask_get, _nmtlib.covar_workspace_lmax_mask_set)
    spin0_only = property(_nmtlib.covar_workspace_spin0_only_get, _nmtlib.covar_workspace_spin0_only_set)
    xi00_1122 = property(_nmtlib.covar_workspace_xi00_1122_get, _nmtlib.covar_workspace_xi00_1122_set)
    xi00_1221 = property(_nmtlib.covar_workspace_xi00_1221_get, _nmtlib.covar_workspace_xi00_1221_set)
    xi02_1122 = property(_nmtlib.covar_workspace_xi02_1122_get, _nmtlib.covar_workspace_xi02_1122_set)
    xi02_1221 = property(_nmtlib.covar_workspace_xi02_1221_get, _nmtlib.covar_workspace_xi02_1221_set)
    xi22p_1122 = property(_nmtlib.covar_workspace_xi22p_1122_get, _nmtlib.covar_workspace_xi22p_1122_set)
    xi22p_1221 = property(_nmtlib.covar_workspace_xi22p_1221_get, _nmtlib.covar_workspace_xi22p_1221_set)
    xi22m_1122 = property(_nmtlib.covar_workspace_xi22m_1122_get, _nmtlib.covar_workspace_xi22m_1122_set)
    xi22m_1221 = property(_nmtlib.covar_workspace_xi22m_1221_get, _nmtlib.covar_workspace_xi22m_1221_set)

    def __init__(self):
        _nmtlib.covar_workspace_swiginit(self, _nmtlib.new_covar_workspace())
    __swig_destroy__ = _nmtlib.delete_covar_workspace

# Register covar_workspace in _nmtlib:
_nmtlib.covar_workspace_swigregister(covar_workspace)


def covar_workspace_free(cw):
    return _nmtlib.covar_workspace_free(cw)

def covar_workspace_init(cl_masks_11_22, cl_masks_12_21, lmax, lmax_mask, l_toeplitz, l_exact, dl_band, spin0_only):
    return _nmtlib.covar_workspace_init(cl_masks_11_22, cl_masks_12_21, lmax, lmax_mask, l_toeplitz, l_exact, dl_band, spin0_only)

def compute_gaussian_covariance(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, clac, clad, clbc, clbd, covar_out):
    return _nmtlib.compute_gaussian_covariance(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, clac, clad, clbc, clbd, covar_out)

def compute_gaussian_covariance_coupled(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, clac, clad, clbc, clbd, covar_out):
    return _nmtlib.compute_gaussian_covariance_coupled(cw, spin_a, spin_b, spin_c, spin_d, wa, wb, clac, clad, clbc, clbd, covar_out)

def workspace_write_fits(w, fname):
    return _nmtlib.workspace_write_fits(w, fname)

def workspace_read_fits(fname, w_unbinned):
    return _nmtlib.workspace_read_fits(fname, w_unbinned)

def workspace_flat_read_fits(fname):
    return _nmtlib.workspace_flat_read_fits(fname)

def workspace_flat_write_fits(w, fname):
    return _nmtlib.workspace_flat_write_fits(w, fname)

def covar_workspace_write_fits(cw, fname):
    return _nmtlib.covar_workspace_write_fits(cw, fname)

def covar_workspace_read_fits(fname, force_spin0):
    return _nmtlib.covar_workspace_read_fits(fname, force_spin0)

def covar_workspace_flat_write_fits(cw, fname):
    return _nmtlib.covar_workspace_flat_write_fits(cw, fname)

def covar_workspace_flat_read_fits(fname):
    return _nmtlib.covar_workspace_flat_read_fits(fname)

def get_nell_list(bins, iout):
    return _nmtlib.get_nell_list(bins, iout)

def get_nell(bins, ibin):
    return _nmtlib.get_nell(bins, ibin)

def get_ell_list(bins, ibin, iout):
    return _nmtlib.get_ell_list(bins, ibin, iout)

def get_weight_list(bins, ibin, dout):
    return _nmtlib.get_weight_list(bins, ibin, dout)

def get_ell_eff(bins, dout):
    return _nmtlib.get_ell_eff(bins, dout)

def get_ell_eff_flat(bins, dout):
    return _nmtlib.get_ell_eff_flat(bins, dout)

def bins_create_py(nell1, nell2, nell3, nell4, lmax):
    return _nmtlib.bins_create_py(nell1, nell2, nell3, nell4, lmax)

def update_mcm(w, n_rows, nell3):
    return _nmtlib.update_mcm(w, n_rows, nell3)

def get_bandpower_windows(w, dout):
    return _nmtlib.get_bandpower_windows(w, dout)

def get_mcm(w, ldout):
    return _nmtlib.get_mcm(w, ldout)

def bins_flat_create_py(npix_1, nell3):
    return _nmtlib.bins_flat_create_py(npix_1, nell3)

def bin_cl(bins, ncl1, dout):
    return _nmtlib.bin_cl(bins, ncl1, dout)

def bin_cl_flat(bins, nell3, ncl1, dout):
    return _nmtlib.bin_cl_flat(bins, nell3, ncl1, dout)

def unbin_cl(bins, ncl1, dout):
    return _nmtlib.unbin_cl(bins, ncl1, dout)

def unbin_cl_flat(bins, ncl1, nell3, dout):
    return _nmtlib.unbin_cl_flat(bins, ncl1, nell3, dout)

def field_alloc_empty_flat(nx, ny, lx, ly, spin, npix_1, ncl1, pure_e, pure_b):
    return _nmtlib.field_alloc_empty_flat(nx, ny, lx, ly, spin, npix_1, ncl1, pure_e, pure_b)

def field_alloc_new_flat(nx, ny, lx, ly, spin, npix_1, nmap_2, ntmp_3, ncl1, pure_e, pure_b, tol_pinv, masked_input, lite):
    return _nmtlib.field_alloc_new_flat(nx, ny, lx, ly, spin, npix_1, nmap_2, ntmp_3, ncl1, pure_e, pure_b, tol_pinv, masked_input, lite)

def field_alloc_new_notemp_flat(nx, ny, lx, ly, spin, npix_1, nmap_2, ncl1, pure_e, pure_b, masked_input, lite):
    return _nmtlib.field_alloc_new_notemp_flat(nx, ny, lx, ly, spin, npix_1, nmap_2, ncl1, pure_e, pure_b, masked_input, lite)

def get_mask_flat(fl, dout):
    return _nmtlib.get_mask_flat(fl, dout)

def get_map_flat(fl, imap, dout):
    return _nmtlib.get_map_flat(fl, imap, dout)

def get_temp_flat(fl, itemp, imap, dout):
    return _nmtlib.get_temp_flat(fl, itemp, imap, dout)

def apomask(npix_1, ldout, aposize, apotype):
    return _nmtlib.apomask(npix_1, ldout, aposize, apotype)

def apomask_flat(nx, ny, lx, ly, npix_1, dout, aposize, apotype):
    return _nmtlib.apomask_flat(nx, ny, lx, ly, npix_1, dout, aposize, apotype)

def synfast_new_flat(nx, ny, lx, ly, nfields, seed, ncl1, ncl2, dout):
    return _nmtlib.synfast_new_flat(nx, ny, lx, ly, nfields, seed, ncl1, ncl2, dout)

def comp_coupling_matrix_anisotropic(spin1, spin2, aniso1, aniso2, lmax, lmax_mask, nl00, nl0e, nl0b, nle0, nlb0, nlee, nleb, nlbe, nlbb, nlb1, nlb2, bin, norm_type, w2):
    return _nmtlib.comp_coupling_matrix_anisotropic(spin1, spin2, aniso1, aniso2, lmax, lmax_mask, nl00, nl0e, nl0b, nle0, nlb0, nlee, nleb, nlbe, nlbb, nlb1, nlb2, bin, norm_type, w2)

def comp_coupling_matrix(spin1, spin2, lmax, lmax_mask, pure_e_1, pure_b_1, pure_e_2, pure_b_2, norm_type, w2, nlb1, nlb2, nell4, bin, is_teb, l_toeplitz, l_exact, dl_band):
    return _nmtlib.comp_coupling_matrix(spin1, spin2, lmax, lmax_mask, pure_e_1, pure_b_1, pure_e_2, pure_b_2, norm_type, w2, nlb1, nlb2, nell4, bin, is_teb, l_toeplitz, l_exact, dl_band)

def comp_general_coupling_matrix(s1, s2, n1, n2, lmax, nell4, dout):
    return _nmtlib.comp_general_coupling_matrix(s1, s2, n1, n2, lmax, nell4, dout)

def comp_coupling_matrix_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, is_teb):
    return _nmtlib.comp_coupling_matrix_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, is_teb)

def read_workspace(fname, w_unbinned):
    return _nmtlib.read_workspace(fname, w_unbinned)

def write_workspace(w, fname):
    return _nmtlib.write_workspace(w, fname)

def read_workspace_flat(fname):
    return _nmtlib.read_workspace_flat(fname)

def write_workspace_flat(w, fname):
    return _nmtlib.write_workspace_flat(w, fname)

def comp_deproj_bias_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, nell3, ncl1, dout):
    return _nmtlib.comp_deproj_bias_flat(fl1, fl2, bin, lmn_x, lmx_x, lmn_y, lmx_y, nell3, ncl1, dout)

def write_covar_workspace(cw, fname):
    return _nmtlib.write_covar_workspace(cw, fname)

def read_covar_workspace(fname, force_spin0):
    return _nmtlib.read_covar_workspace(fname, force_spin0)

def covar_workspace_init_py(nlb1, nlb2, lmax, lmax_mask, l_toeplitz, l_exact, dl_band, spin0_only):
    return _nmtlib.covar_workspace_init_py(nlb1, nlb2, lmax, lmax_mask, l_toeplitz, l_exact, dl_band, spin0_only)

def write_covar_workspace_flat(cw, fname):
    return _nmtlib.write_covar_workspace_flat(cw, fname)

def read_covar_workspace_flat(fname):
    return _nmtlib.read_covar_workspace_flat(fname)

def covar_workspace_flat_init_py(fa1, fa2, ba, fb1, fb2, bb):
    return _nmtlib.covar_workspace_flat_init_py(fa1, fa2, ba, fb1, fb2, bb)

def comp_gaussian_covariance(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, ncl11, ncl12, ncl21, ncl22, dout):
    return _nmtlib.comp_gaussian_covariance(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, ncl11, ncl12, ncl21, ncl22, dout)

def comp_gaussian_covariance_coupled(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, ncl11, ncl12, ncl21, ncl22, dout):
    return _nmtlib.comp_gaussian_covariance_coupled(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, ncl11, ncl12, ncl21, ncl22, dout)

def comp_gaussian_covariance_flat(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, nell3, ncl11, ncl12, ncl21, ncl22, dout):
    return _nmtlib.comp_gaussian_covariance_flat(cw, spin_a1, spin_a2, spin_b1, spin_b2, wa, wb, nell3, ncl11, ncl12, ncl21, ncl22, dout)

def comp_pspec_coupled_flat(fl1, fl2, bin, dout, lmn_x, lmx_x, lmn_y, lmx_y):
    return _nmtlib.comp_pspec_coupled_flat(fl1, fl2, bin, dout, lmn_x, lmx_x, lmn_y, lmx_y)

def decouple_cell_py(w, ncl1, ncl2, ncl3, dout):
    return _nmtlib.decouple_cell_py(w, ncl1, ncl2, ncl3, dout)

def decouple_cell_py_flat(w, ncl1, ncl2, ncl3, dout):
    return _nmtlib.decouple_cell_py_flat(w, ncl1, ncl2, ncl3, dout)

def couple_cell_py(w, ncl1, dout):
    return _nmtlib.couple_cell_py(w, ncl1, dout)

def couple_cell_py_flat(w, nell3, ncl1, dout):
    return _nmtlib.couple_cell_py_flat(w, nell3, ncl1, dout)

def wsp_update_beams(w, nlb1, nlb2):
    return _nmtlib.wsp_update_beams(w, nlb1, nlb2)

def wsp_update_bins(w, b):
    return _nmtlib.wsp_update_bins(w, b)

def comp_pspec_flat(fl1, fl2, bin, w0, ncl1, nell3, ncl2, dout, lmn_x, lmx_x, lmn_y, lmx_y):
    return _nmtlib.comp_pspec_flat(fl1, fl2, bin, w0, ncl1, nell3, ncl2, dout, lmn_x, lmx_x, lmn_y, lmx_y)

def get_ell_sampling_flat(f, dout):
    return _nmtlib.get_ell_sampling_flat(f, dout)


